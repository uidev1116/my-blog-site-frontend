This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.husky/
  .gitignore
  pre-commit
app/
  api/
    blog/
      draft/
        route.ts
      route.ts
    index.ts
  blog/
    [code]/
      opengraph-image.tsx
      page.tsx
    api/
      index.ts
    page/
      [page]/
        page.tsx
    routes/
      BlogDetailRoute.tsx
      BlogIndexRoute.tsx
    search/
      page/
        [page]/
          page.tsx
      page.tsx
    tag/
      [tag]/
        page/
          [page]/
            page.tsx
        layout.tsx
        page.tsx
      api/
        index.ts
    zenn/
      api/
        index.ts
      page/
        [page]/
          page.tsx
      routes/
        ZennArticleIndexRoute.tsx
      page.tsx
    page.tsx
  components/
    Badge/
      Badge.tsx
      index.ts
    BlogSearchForm/
      BlogSearchForm.tsx
      index.ts
    BuildInJs/
      BuildInJs.tsx
      index.ts
    Card/
      Card.tsx
      CardBody.tsx
      CardFooter.tsx
      CardHeader.tsx
      index.ts
    Collapse/
      Collapse.tsx
      index.tsx
    ComboBox/
      ComboBox.tsx
      index.ts
    ConditionalWrapper/
      ConditionalWrapper.tsx
      index.ts
    Container/
      Container.tsx
      index.ts
    CopyToClipboard/
      CopyToClipboard.tsx
      index.ts
    CreatedTime/
      CreatedTime.tsx
      index.ts
    EmptyState/
      EmptyState.tsx
      index.ts
    EntryList/
      EntryList.tsx
      index.ts
    Footer/
      Footer.tsx
      index.ts
    Header/
      Header.tsx
      index.ts
      Logo.tsx
      NavLink.tsx
    NextNProgress/
      index.ts
      NextNProgress.tsx
    Pagination/
      index.ts
      Pagination.tsx
    RichLink/
      index.ts
      RichLink.tsx
    ShareSocialMedia/
      index.ts
      ShareSocialMedia.tsx
    Spinner/
      index.ts
      Spinner.tsx
    Tabs/
      index.ts
      Tab.tsx
      TabList.tsx
      Tabs.tsx
    TagList/
      index.ts
      TagList.tsx
    ThemeColorSwitcher/
      index.ts
      ThemeColorSwitcher.tsx
    Unit/
      Types/
        MediaUnit/
          index.ts
          MediaUnit.tsx
        OpenStreetMapUnit/
          index.ts
          OpenStreetMapUnit.tsx
        QuoteUnit/
          index.ts
          QuoteUnit.tsx
        RichEditorUnit/
          index.ts
          RichEditorUnit.tsx
        TableUnit/
          index.ts
          TableUnit.tsx
        TextUnit/
          index.ts
          TextUnit.tsx
        index.ts
      index.ts
      Unit.tsx
    UnitIndex/
      index.ts
      UnitIndex.tsx
    ZennArticleList/
      index.ts
      ZennArticleList.tsx
    index.ts
  config/
    acms.ts
    index.ts
  feed/
    api/
      index.ts
    route.ts
  hooks/
    useBlogEntriesSwrMutation/
      index.ts
      useBlogEntriesSwrMutation.tsx
    useBrowser/
      index.ts
      useBrowser.ts
    useClipboard/
      index.ts
      useClipboard.ts
    usePageChange/
      index.ts
      usePageChange.ts
    useUrlMatch/
      index.ts
      useUrlMatch.ts
    index.ts
  lib/
    acms/
      index.ts
    buildIn/
      document-outliner.ts
      index.ts
      lazy-load-fn.ts
      open-street-map.ts
      scroll-hint.ts
      smart-photo.ts
    font/
      google/
        index.ts
        loadFont.ts
  profile/
    api/
      index.ts
    routes/
      ProfileRoute.tsx
    page.tsx
  routes/
    HomeRoute.tsx
  stores/
    color-theme.tsx
  types/
    enums/
      BlogStatus.ts
      CategoryStatus.ts
      EntryStatus.ts
      index.ts
      MediaStatus.ts
      MediaType.ts
      UnitAlign.ts
      UnitType.ts
      UserAuth.ts
      UserStatus.ts
    units/
      interfaces/
        index.ts
      BreakUnit.ts
      ExImageUnit.ts
      FileUnit.ts
      GoogleMapUnit.ts
      ImageUnit.ts
      index.ts
      MediaUnit.ts
      ModuleUnit.ts
      OpenStreatMapUnit.ts
      QuoteUnit.ts
      RichEditorUnit.ts
      TableUnit.ts
      TextUnit.ts
      VideoUnit.ts
    zenn/
      Article.ts
      index.ts
      User.ts
    Blog.ts
    Category.ts
    Entry.ts
    index.ts
    Media.ts
    smartphoto.d.ts
    Tag.ts
    Unit.ts
    User.ts
  utils/
    deleteNewLine.ts
    encodeUri.ts
    groupByUnitGroup.ts
    index.ts
    isBrowser.ts
    isDateString.ts
    isExternalLink.ts
    isNumber.ts
    isObject.ts
    isString.ts
    nl2br.ts
    noop.ts
    objToSearchParams.ts
    range.ts
    react-nl2br.ts
    resolveRequestCache.ts
    truncate.ts
  apple-icon.png
  favicon.ico
  globals.css
  icon.svg
  layout.tsx
  not-found.tsx
  page.tsx
  sitemap.ts
public/
  logo-dark.svg
  logo-light.svg
types/
  env.d.ts
.gitignore
.lintstagedrc.js
CLAUDE.md
eslint.config.js
next.config.js
package.json
postcss.config.js
prettier.config.js
README.md
tailwind.config.js
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".husky/.gitignore">
_
</file>

<file path=".husky/pre-commit">
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

npx lint-staged
</file>

<file path="app/api/blog/route.ts">
import { getBlogEntries } from '@/app/blog/api';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const { entries } = await getBlogEntries({ searchParams });

  return Response.json({ entries });
}
</file>

<file path="app/blog/[code]/opengraph-image.tsx">
import { loadFont } from '@/app/lib/font/google';
import { ImageResponse } from 'next/og';
import { getBlogEntry } from '../api';
import { getOgp } from '@/app/api';
import { MEDIA_BASE_URL } from '@/app/config/acms';

export const runtime = 'edge';

export const revalidate = 10;

export const alt = '記事のOGP画像';
export const size = {
  width: 1200,
  height: 630,
};

export const contentType = 'image/png';

// Image generation
export default async function Image({ params }: { params: { code: string } }) {
  // entry
  const entry = await getBlogEntry(params.code);

  if (entry === null) {
    return new Response('Not Found', { status: 404 });
  }

  // Font
  const notoSansArrayBuffer = await loadFont({
    family: 'Noto Sans JP',
    weight: 700,
    text: entry.title,
  });

  const backgroundImage = `${MEDIA_BASE_URL}${
    entry.blog?.ogpImageBasePath
  }?type=original&?date=${new Date().getTime()}`;

  return new ImageResponse(
    (
      <div
        style={{
          backgroundImage: `url("${backgroundImage}")`,
          backgroundColor: '#fff',
          backgroundSize: '100% 100%',
          height: '100%',
          width: '100%',
          display: 'flex',
          textAlign: 'left',
          alignItems: 'flex-start',
          justifyContent: 'center',
          flexDirection: 'column',
          flexWrap: 'nowrap',
        }}
      >
        <div
          style={{
            width: '100%',
            fontSize: 48,
            fontStyle: 'normal',
            fontWeight: 'bold',
            color: '#000',
            padding: '0 120px',
            lineHeight: 1.3,
            marginBottom: '30px',
            wordWrap: 'break-word',
          }}
        >
          {entry.title}
        </div>
      </div>
    ),
    {
      ...size,
      fonts: [
        {
          name: 'NotoSansJP',
          data: notoSansArrayBuffer,
          style: 'normal',
          weight: 700,
        },
      ],
    },
  );
}
</file>

<file path="app/blog/tag/api/index.ts">
import acmsClient from '@/app/lib/acms';
import { resolveRequestCache } from '@/app/utils';

export async function getAllBlogTags(): Promise<string[]> {
  const { data } = await acmsClient.get(
    {
      blog: 'blog',
      api: 'tag_index',
    },
    { requestInit: { cache: resolveRequestCache() } },
  );

  const { 'tag:loop': tags = [] } = data;

  return tags.map((tag: { name: string }) => tag.name);
}
</file>

<file path="app/components/Badge/index.ts">
export { default as Badge } from './Badge';
</file>

<file path="app/components/BuildInJs/BuildInJs.tsx">
'use client';

import { usePageChange } from '@/app/hooks';
import {
  documentOutliner,
  externalLinks,
  openStreetMap,
  scrollHint,
  smartPhoto,
} from '@/app/lib/buildIn';
import { Suspense, useEffect } from 'react';

function BuildInJs() {
  usePageChange(() => {
    if (typeof window !== 'undefined') {
      ((context: Document | Element) => {
        externalLinks(context);
        smartPhoto(context);
        scrollHint(context);
        openStreetMap(context);
        documentOutliner(context);
      })(document);
    }
  });
  return null;
}

export default function BuildInJsSuspense() {
  return (
    <Suspense fallback={null}>
      <BuildInJs />
    </Suspense>
  );
}
</file>

<file path="app/components/BuildInJs/index.ts">
export { default as BuildInJs } from './BuildInJs';
</file>

<file path="app/components/Card/Card.tsx">
import clsx from 'clsx';
import { ComponentPropsWithoutRef, forwardRef } from 'react';

type Props = ComponentPropsWithoutRef<'div'> & {
  as?: React.ElementType;
  chidren?: React.ReactNode;
};

export default forwardRef<'div', Props>(function Card(
  { as: Component = 'div', className, children, ...props },
  ref,
) {
  return (
    <Component
      ref={ref}
      className={clsx(
        'flex h-full w-full flex-col gap-y-2 rounded-lg border border-gray-200 bg-white p-6 shadow hover:bg-gray-100 dark:border-gray-700 dark:bg-gray-800 dark:hover:bg-gray-700',
        className,
      )}
      {...props}
    >
      {children}
    </Component>
  );
});
</file>

<file path="app/components/Card/CardBody.tsx">
import { ComponentPropsWithoutRef, ElementType, forwardRef } from 'react';

type Props = ComponentPropsWithoutRef<'div'> & {
  as?: React.ElementType;
  chidren?: React.ReactNode;
};

export default forwardRef<'div', Props>(function CardBody(
  { as: Component = 'div', children, ...props },
  ref,
) {
  return (
    <Component ref={ref} {...props}>
      {children}
    </Component>
  );
});
</file>

<file path="app/components/Card/CardFooter.tsx">
import { ComponentPropsWithoutRef, ElementType, forwardRef } from 'react';

type Props = ComponentPropsWithoutRef<'div'> & {
  as?: React.ElementType;
  chidren?: React.ReactNode;
};

export default forwardRef<'div', Props>(function CardFooter(
  { as: Component = 'div', children, ...props },
  ref,
) {
  return (
    <Component ref={ref} {...props}>
      {children}
    </Component>
  );
});
</file>

<file path="app/components/Card/CardHeader.tsx">
import { ComponentPropsWithoutRef, ElementType, forwardRef } from 'react';

type Props = ComponentPropsWithoutRef<'div'> & {
  as?: React.ElementType;
  chidren?: React.ReactNode;
};

export default forwardRef<'div', Props>(function CardHeader(
  { as: Component = 'div', children, ...props },
  ref,
) {
  return (
    <Component ref={ref} {...props}>
      {children}
    </Component>
  );
});
</file>

<file path="app/components/Card/index.ts">
export { default as Card } from './Card';
export { default as CardBody } from './CardBody';
export { default as CardFooter } from './CardFooter';
export { default as CardHeader } from './CardHeader';
</file>

<file path="app/components/Collapse/Collapse.tsx">
'use client';

import { Suspense, useEffect } from 'react';
import { initCollapses } from 'flowbite';

import type { ComponentProps } from 'react';
import { usePageChange } from '@/app/hooks';

type Props = Omit<
  ComponentProps<'button'>,
  'type' | 'aria-controls' | 'aria-expanded' | 'data-collapse-toggle'
> & {
  toggle: string;
  children?: React.ReactNode;
};

function Collapse({ toggle, children, ...props }: Props) {
  useEffect(() => {
    initCollapses();
  }, []);

  usePageChange(() => {
    // @ts-ignore
    const collapse = FlowbiteInstances.getInstance('Collapse', toggle);
    collapse.collapse();
  });

  return (
    <button
      type="button"
      data-collapse-toggle={toggle}
      aria-controls={toggle}
      aria-expanded="false"
      {...props}
    >
      {children}
    </button>
  );
}

export default function CollapseSuspense(props: Props) {
  return (
    <Suspense fallback={null}>
      <Collapse {...props} />
    </Suspense>
  );
}
</file>

<file path="app/components/Collapse/index.tsx">
export { default as Collapse } from './Collapse';
</file>

<file path="app/components/ComboBox/index.ts">
export { default as ComboBox } from './ComboBox';
</file>

<file path="app/components/ConditionalWrapper/index.ts">
export { default as ConditionalWrapper } from './ConditionalWrapper';
</file>

<file path="app/components/Container/Container.tsx">
type Props = {
  children?: React.ReactNode;
};

export default function Container({ children }: Props) {
  return (
    <div className="px-4 py-8 lg:container lg:mx-auto lg:py-12">{children}</div>
  );
}
</file>

<file path="app/components/Container/index.ts">
export { default as Container } from './Container';
</file>

<file path="app/components/EmptyState/EmptyState.tsx">
type Props = {
  children?: React.ReactNode;
};
export default function EmptyState({
  children = <p>お探しの記事が見つかりませんでした。</p>,
}: Props) {
  return (
    <div className="mx-auto flex flex-wrap items-center justify-between rounded-md bg-white dark:bg-slate-500">
      <div className="flex w-full justify-center rounded-md border-2 border-dashed border-slate-200 p-20 dark:border-slate-100">
        <div className="text-center">
          <div className="mb-4 grid place-items-center">
            <svg
              className="h-[32px] w-[32px] text-gray-800 dark:text-white"
              aria-hidden="true"
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 20 18"
            >
              <path
                stroke="currentColor"
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth="2"
                d="M10 16.5c0-1-8-2.7-9-2V1.8c1-1 9 .707 9 1.706M10 16.5V3.506M10 16.5c0-1 8-2.7 9-2V1.8c-1-1-9 .707-9 1.706"
              />
            </svg>
          </div>
          <div className="space-y-2 text-xl dark:text-white">{children}</div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="app/components/EmptyState/index.ts">
export { default as EmptyState } from './EmptyState';
</file>

<file path="app/components/EntryList/index.ts">
export { default as EntryList } from './EntryList';
</file>

<file path="app/components/Footer/index.ts">
export { default as Footer } from './Footer';
</file>

<file path="app/components/Header/index.ts">
export { default as Header } from './Header';
</file>

<file path="app/components/Header/NavLink.tsx">
'use client';

import Link from 'next/link';
import { useUrlMatch } from '@/app/hooks';

import { BASE_URL } from '@/app/config';
import clsx from 'clsx';
import { Suspense, useMemo } from 'react';

type Props = {
  href: string;
  target?: React.HTMLAttributeAnchorTarget;
  rel?: string;
  children?: React.ReactNode;
};

function NavLinkBase({ href, target, rel, children }: Props) {
  const url = new URL(href, BASE_URL);
  const { isMatchFull, isMatchStart } = useUrlMatch(url);

  const baseStyles = 'block rounded py-2 pl-3 pr-4 md:p-0';
  const activeStyles =
    'bg-primary text-white md:bg-transparent md:text-primary md:dark:text-primary';
  const inactiveStyles =
    'text-gray-900 hover:bg-gray-100 dark:border-gray-700 dark:text-white dark:hover:bg-gray-700 dark:hover:text-white md:hover:bg-transparent md:hover:text-primary-darker md:dark:hover:bg-transparent md:dark:hover:text-primary-darker';

  const isMatch = useMemo(
    () => (href === '/' ? isMatchFull : isMatchStart),
    [href, isMatchFull, isMatchStart],
  );

  return (
    <Link
      href={href}
      className={clsx(baseStyles, {
        [activeStyles]: isMatch === true,
        [inactiveStyles]: isMatch === false,
      })}
      target={target}
      rel={rel}
      aria-current={isMatchFull ? 'page' : undefined}
    >
      {children}
    </Link>
  );
}

export default function NavLink(props: Props) {
  return (
    <Suspense fallback={null}>
      <NavLinkBase {...props} />
    </Suspense>
  );
}
</file>

<file path="app/components/NextNProgress/index.ts">
export { default as NextNProgress } from './NextNProgress';
</file>

<file path="app/components/Pagination/index.ts">
export { default as Pagination } from './Pagination';
</file>

<file path="app/components/Pagination/Pagination.tsx">
'use client';

import Link from 'next/link';
import { useSearchParams } from 'next/navigation';
import { Suspense, useMemo } from 'react';

type Props = {
  currentPage: number;
  previous?: {
    path: string;
    num: number;
    page: number;
  };
  pages: {
    page: number;
    path: string;
  }[];
  next?: {
    path: string;
    num: number;
    page: number;
  };
};

function Pagination({ currentPage, pages, previous, next }: Props) {
  const searchParams = useSearchParams();
  const queryString = useMemo(
    () => (searchParams.toString() ? `?${searchParams.toString()}` : ''),
    [searchParams],
  );
  return (
    <nav aria-label="Page navigation">
      <ul className="flex h-10 items-center -space-x-px text-base">
        {previous && (
          <li>
            <Link
              href={`${previous.path}${queryString}`}
              className="ml-0 flex h-10 items-center justify-center rounded-l-lg border border-gray-300 bg-white px-4 leading-tight text-gray-500 hover:bg-gray-100 hover:text-gray-700 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white"
            >
              <span className="sr-only">Previous</span>
              <svg
                className="h-3 w-3"
                aria-hidden="true"
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 6 10"
              >
                <path
                  stroke="currentColor"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="M5 1 1 5l4 4"
                />
              </svg>
            </Link>
          </li>
        )}
        {pages.length > 0 &&
          pages.map(({ page, path }) => (
            <li key={page}>
              {page === currentPage ? (
                <span className="flex h-10 items-center justify-center border border-gray-300 bg-primary-lightest px-4 leading-tight text-primary hover:bg-primary-lighter hover:text-primary-darker dark:border-gray-700 dark:bg-gray-700 dark:text-white">
                  {page}
                </span>
              ) : (
                <Link
                  href={`${path}${queryString}`}
                  className="flex h-10 items-center justify-center border border-gray-300 bg-white px-4 leading-tight text-gray-500 hover:bg-gray-100 hover:text-gray-700 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white"
                >
                  {page}
                </Link>
              )}
            </li>
          ))}
        {next && (
          <li>
            <Link
              href={`${next.path}${queryString}`}
              className="flex h-10 items-center justify-center rounded-r-lg border border-gray-300 bg-white px-4 leading-tight text-gray-500 hover:bg-gray-100 hover:text-gray-700 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white"
            >
              <span className="sr-only">Next</span>
              <svg
                className="h-3 w-3"
                aria-hidden="true"
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 6 10"
              >
                <path
                  stroke="currentColor"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth={2}
                  d="m1 9 4-4-4-4"
                />
              </svg>
            </Link>
          </li>
        )}
      </ul>
    </nav>
  );
}

export default function PaginationSuspense(props: Props) {
  return (
    <Suspense fallback={null}>
      <Pagination {...props} />
    </Suspense>
  );
}
</file>

<file path="app/components/ShareSocialMedia/index.ts">
export { default as ShareSocialMedia } from './ShareSocialMedia';
</file>

<file path="app/components/Tabs/index.ts">
export { default as Tabs } from './Tabs';
export { default as Tab } from './Tab';
export { default as TabList } from './TabList';
</file>

<file path="app/components/Tabs/Tab.tsx">
import { forwardRef } from 'react';

type Props = React.ComponentPropsWithoutRef<'li'> & {
  children: React.ReactNode;
};

export default forwardRef<HTMLLIElement, Props>(function Tab(
  { className = 'me-2', children, ...rest },
  ref,
) {
  return (
    <li ref={ref} className={className} {...rest}>
      {children}
    </li>
  );
});
</file>

<file path="app/components/Tabs/TabList.tsx">
import { clsx } from 'clsx';
import { forwardRef } from 'react';

type Props = React.ComponentPropsWithoutRef<'ul'> & {
  children: React.ReactNode;
};

export default forwardRef<HTMLUListElement, Props>(function TabList(
  {
    className = 'border-b border-gray-200 text-center text-sm font-medium text-black dark:border-gray-700 dark:text-white',
    children,
    ...rest
  },
  ref,
) {
  return (
    <ul
      ref={ref}
      className={clsx('-mb-px flex flex-wrap', className)}
      {...rest}
    >
      {children}
    </ul>
  );
});
</file>

<file path="app/components/Tabs/Tabs.tsx">
import { forwardRef } from 'react';

type Props = React.ComponentPropsWithoutRef<'div'> & {
  children: React.ReactNode;
};

export default forwardRef<HTMLDivElement, Props>(function Tabs(
  { className = 'flex flex-col gap-10', children, ...rest },
  ref,
) {
  return (
    <div ref={ref} className={className} {...rest}>
      {children}
    </div>
  );
});
</file>

<file path="app/components/TagList/index.ts">
export { default as TagList } from './TagList';
</file>

<file path="app/components/Unit/Types/MediaUnit/index.ts">
export { default as MediaUnit } from './MediaUnit';
</file>

<file path="app/components/Unit/Types/OpenStreetMapUnit/index.ts">
export { default as OpenStreetMapUnit } from './OpenStreetMapUnit';
</file>

<file path="app/components/Unit/Types/OpenStreetMapUnit/OpenStreetMapUnit.tsx">
import type { Unit, OpenStreetMapUnit } from '@/app/types';

export default function OpenStreetMapUnit({
  displaySize,
  lat,
  lng,
  zoom,
  message,
  x,
  y,
}: Unit<OpenStreetMapUnit>) {
  return (
    <div className="w-100">
      <div
        className="js-open-street-map max-w-full"
        data-lazy="true"
        data-lat={lat}
        data-lng={lng}
        data-zoom={zoom}
        data-msg={message}
        style={{ width: `${x}px`, height: `${y}px` }}
      ></div>
    </div>
  );
}
</file>

<file path="app/components/Unit/Types/RichEditorUnit/index.ts">
export { default as RichEditorUnit } from './RichEditorUnit';
</file>

<file path="app/components/Unit/Types/TableUnit/index.ts">
export { default as TableUnit } from './TableUnit';
</file>

<file path="app/components/Unit/Types/TextUnit/index.ts">
export { default as TextUnit } from './TextUnit';
</file>

<file path="app/components/Unit/index.ts">
export { default as Unit } from './Unit';
</file>

<file path="app/components/UnitIndex/index.ts">
export { default as UnitIndex } from './UnitIndex';
</file>

<file path="app/components/UnitIndex/UnitIndex.tsx">
import { Unit } from '@/app/components';
import type { Unit as UnitType } from '@/app/types';

type Props = {
  units: UnitType[];
};

export default function UnitIndex({ units }: Props) {
  return units.map((unit) => <Unit key={unit.id} unit={unit} />);
}
</file>

<file path="app/components/ZennArticleList/index.ts">
export { default as ZennArticleList } from './ZennArticleList';
</file>

<file path="app/hooks/usePageChange/index.ts">
export { default as usePageChange } from './usePageChange';
</file>

<file path="app/hooks/usePageChange/usePageChange.ts">
'use client';

import {
  ReadonlyURLSearchParams,
  usePathname,
  useSearchParams,
} from 'next/navigation';
import { useCallback, useEffect } from 'react';

export default function usePageChange(
  onPageChange: (
    pathname: string,
    searchParams: ReadonlyURLSearchParams,
  ) => void,
) {
  const pathname = usePathname();
  const searchParams = useSearchParams();

  const handlePageChange = useCallback(
    (pathname: string, searchParams: ReadonlyURLSearchParams) => {
      onPageChange(pathname, searchParams);
    },
    // 再レンダリングを防ぐために、onPageChangeを依存配列に含めない
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [],
  );

  useEffect(() => {
    handlePageChange(pathname, searchParams);
  }, [pathname, searchParams, handlePageChange]);
}
</file>

<file path="app/hooks/useUrlMatch/index.ts">
export { default as useUrlMatch } from './useUrlMatch';
export type * from './useUrlMatch';
</file>

<file path="app/hooks/useUrlMatch/useUrlMatch.ts">
import { useState, useEffect } from 'react';
import { usePathname, useSearchParams } from 'next/navigation';

import { encodeUri } from '@/app/utils';

export type UseUrlMatchReturn = {
  isMatchFull: boolean;
  isMatchStart: boolean;
};

export default function useUrlMatch(url: URL) {
  const pathname = usePathname();
  const searchParams = useSearchParams();

  const [isMatchFull, setIsMatchFull] = useState(false);
  const [isMatchStart, setIsMatchStart] = useState(false);

  useEffect(() => {
    const href = `${pathname}${
      searchParams.toString() ? `?${searchParams}` : ''
    }`;
    const target = `${url.pathname}${url.search}`;
    const isMatchFull = [href, encodeUri(href)].includes(target);
    const isMatchStart =
      href.startsWith(target) || encodeUri(href).startsWith(target);
    setIsMatchFull(isMatchFull);
    setIsMatchStart(isMatchStart);
  }, [pathname, searchParams, url.search, url.pathname]);

  return { isMatchFull, isMatchStart };
}
</file>

<file path="app/lib/buildIn/lazy-load-fn.ts">
import lozad from 'lozad';

export default function lazyLoad(
  selector: string,
  isLazy: (element: HTMLElement) => boolean,
  run: (element: HTMLElement) => void,
) {
  const observer = lozad(selector, {
    loaded: (el: HTMLElement) => {
      if (isLazy(el)) {
        run(el);
      }
    },
  });
  observer.observe();
  [].forEach.call(document.querySelectorAll(selector), (item: HTMLElement) => {
    if (!isLazy(item)) {
      run(item);
    }
  });
}
</file>

<file path="app/lib/font/google/index.ts">
export { default as loadFont } from './loadFont';
</file>

<file path="app/lib/font/google/loadFont.ts">
/**
 * Google FontsのCSSファイルから、
 * フォントURL `src: url(ここ) format(truetype OR opentype)` を探し、
 * 見つかればfetchしてArrayBufferにして返す
 * @see https://github.com/kvnang/workers-og/blob/main/packages/workers-og/src/font.ts
 * @see https://zenn.dev/uzimaru0000/articles/satori-workers
 *
 * 調べてみると、next/fontも同じようなことをしている
 * @see https://github.com/vercel/next.js/blob/canary/packages/font/src/google/find-font-files-in-css.ts
 */
export default async function loadFont({
  family,
  weight,
  text,
}: {
  family: string;
  weight?: number;
  text?: string;
}) {
  const params = new URLSearchParams({
    family: `${family}${weight ? `:wght@${weight}` : ''}`,
  });
  if (text) {
    params.append('text', text);
  } else {
    params.append('subset', 'latin');
  }

  const url = `https://fonts.googleapis.com/css2?${params.toString()}`;

  const css = await fetch(url).then((res) => res.text());

  const fontUrl = css.match(
    /src: url\((.+)\) format\('(opentype|truetype)'\)/,
  )?.[1];

  if (!fontUrl) {
    throw new Error('Font file not found in CSS fetched from Google Fonts');
  }

  return fetch(fontUrl).then((res) => res.arrayBuffer());
}
</file>

<file path="app/types/enums/BlogStatus.ts">
export type BlogStatus = 'open' | 'close' | 'secret';
</file>

<file path="app/types/enums/CategoryStatus.ts">
export type CategoryStatus = 'open' | 'close';
</file>

<file path="app/types/enums/EntryStatus.ts">
export type EntryStatus = 'open' | 'close' | 'draft' | 'trash';
</file>

<file path="app/types/enums/index.ts">
export * from './BlogStatus';
export * from './CategoryStatus';
export * from './EntryStatus';
export * from './UnitAlign';
export * from './UnitType';
export * from './UserAuth';
export * from './UserStatus';
export * from './MediaStatus';
export * from './MediaType';
</file>

<file path="app/types/enums/MediaStatus.ts">
export type MediaStatus = 'entry' | 'open' | 'close' | 'secret';
</file>

<file path="app/types/enums/MediaType.ts">
export type MediaType = 'image' | 'file' | 'svg';
</file>

<file path="app/types/enums/UnitAlign.ts">
export type UnitAlign = 'auto' | 'left' | 'right' | 'center' | 'hidden';
</file>

<file path="app/types/enums/UnitType.ts">
export type UnitType =
  | 'text'
  | 'table'
  | 'image'
  | 'file'
  | 'map'
  | 'osmap'
  | 'video'
  | 'eximage'
  | 'quote'
  | 'media'
  | 'rich-editor'
  | 'break'
  | 'module'
  | 'custom';
</file>

<file path="app/types/enums/UserAuth.ts">
export type UserAuth =
  | 'administrator'
  | 'editor'
  | 'contributor'
  | 'subscriber';
</file>

<file path="app/types/enums/UserStatus.ts">
export type UserStatus = 'open' | 'close';
</file>

<file path="app/types/units/interfaces/index.ts">
export interface UnitInterface {}
</file>

<file path="app/types/units/BreakUnit.ts">
import type { Unit } from '..';
import type { UnitInterface } from './interfaces';

export interface BreakUnit extends UnitInterface {
  label?: string;
  url?: string;
}

export const isBreakUnit = (unit: Unit): unit is Unit<BreakUnit> => {
  return unit.type === 'break';
};
</file>

<file path="app/types/units/ExImageUnit.ts">
import type { Unit } from '..';
import { UnitInterface } from './interfaces';

export interface ExImageUnit extends UnitInterface {
  x: number;
  y: number;
  caption: string;
  path: string;
  largePath: string;
  link: string;
  alt: string;
  displaySize: string;
}

export const isExImageUnit = (unit: Unit): unit is Unit<ExImageUnit> => {
  return unit.type === 'eximage';
};
</file>

<file path="app/types/units/FileUnit.ts">
import type { Unit } from '..';
import { UnitInterface } from './interfaces';

export interface FileUnit extends UnitInterface {
  caption: string;
  path: string;
  iconPath: string;
  x: number;
  y: number;
}

export const isFileUnit = (unit: Unit): unit is Unit<FileUnit> => {
  return unit.type === 'file';
};
</file>

<file path="app/types/units/GoogleMapUnit.ts">
import type { Unit } from '..';
import { UnitInterface } from './interfaces';

export interface GoogleMapUnit extends UnitInterface {
  x: number;
  y: number;
  message: string;
  lat: number;
  lng: number;
  zoom: number;
  displaySize: string;
  view: {
    pitch: number;
    zoom: number;
    heading: number;
  };
}

export const isGoogleMapUnit = (unit: Unit): unit is Unit<GoogleMapUnit> => {
  return unit.type === 'map';
};
</file>

<file path="app/types/units/ImageUnit.ts">
import type { Unit } from '..';
import { UnitInterface } from './interfaces';

export interface ImageUnit extends UnitInterface {
  caption: string;
  path: string;
  x: number | null;
  y: number | null;
  link: string;
  alt: string;
  displaySize: string;
  exif: string;
  tinyPath?: string;
  tinyX?: number;
  tinyY?: number;
  squarePath?: string;
  squareX?: number;
  squareY?: number;
  largePath?: string;
  largeX?: number;
  largeY?: number;
}

export const isImageUnit = (unit: Unit): unit is Unit<ImageUnit> => {
  return unit.type === 'image';
};
</file>

<file path="app/types/units/index.ts">
export * from './BreakUnit';
export * from './ExImageUnit';
export * from './FileUnit';
export * from './GoogleMapUnit';
export * from './ImageUnit';
export * from './MediaUnit';
export * from './ModuleUnit';
export * from './OpenStreatMapUnit';
export * from './QuoteUnit';
export * from './RichEditorUnit';
export * from './TableUnit';
export * from './TextUnit';
export * from './VideoUnit';
</file>

<file path="app/types/units/MediaUnit.ts">
import type { Media, Unit } from '..';
import { UnitInterface } from './interfaces';

export interface MediaUnit extends UnitInterface {
  media: Media & {
    x: number;
    y: number | null;
    useIcon?: boolean;
    eid?: number;
  };
  displaySize: string;
}

export const isMediaUnit = (unit: Unit): unit is Unit<MediaUnit> => {
  return unit.type === 'media';
};
</file>

<file path="app/types/units/ModuleUnit.ts">
import type { Unit } from '..';
import { UnitInterface } from './interfaces';

export interface ModuleUnit extends UnitInterface {
  view: string;
}

export const isModuleUnit = (unit: Unit): unit is Unit<ModuleUnit> => {
  return unit.type === 'module';
};
</file>

<file path="app/types/units/OpenStreatMapUnit.ts">
import type { Unit } from '..';
import { UnitInterface } from './interfaces';

export interface OpenStreetMapUnit extends UnitInterface {
  x: number;
  y: number;
  message: string;
  lat: number;
  lng: number;
  zoom: number;
  displaySize: string;
}

export const isOpenStreetMapUnit = (
  unit: Unit,
): unit is Unit<OpenStreetMapUnit> => {
  return unit.type === 'osmap';
};
</file>

<file path="app/types/units/QuoteUnit.ts">
import type { Unit } from '..';
import { UnitInterface } from './interfaces';

export interface QuoteUnit extends UnitInterface {
  siteName: string;
  author: string;
  title: string;
  description: string;
  image: string;
  url: string;
  html: string;
}

export const isQuoteUnit = (unit: Unit): unit is Unit<QuoteUnit> => {
  return unit.type === 'quote';
};
</file>

<file path="app/types/units/RichEditorUnit.ts">
import type { Unit } from '..';
import { UnitInterface } from './interfaces';

export interface RichEditorUnit extends UnitInterface {
  html: string;
}

export const isRichEditorUnit = (unit: Unit): unit is Unit<RichEditorUnit> => {
  return unit.type === 'rich-editor';
};
</file>

<file path="app/types/units/TableUnit.ts">
import type { Unit } from '..';
import { UnitInterface } from './interfaces';

export interface TableUnit extends UnitInterface {
  table: string;
}

export const isTableUnit = (unit: Unit): unit is Unit<TableUnit> => {
  return unit.type === 'table';
};
</file>

<file path="app/types/units/TextUnit.ts">
import type { Unit } from '..';
import { UnitInterface } from './interfaces';

export interface TextUnit extends UnitInterface {
  text: string;
  tag:
    | 'p'
    | 'h1'
    | 'h2'
    | 'h3'
    | 'h4'
    | 'h5'
    | 'h6'
    | 'ul'
    | 'ol'
    | 'dl'
    | 'blockquote'
    | 'table'
    | 'pre'
    | 'none'
    | 'markdown'
    | 'wysiwyg';
  extendTag: string;
}

export const isTextUnit = (unit: Unit): unit is Unit<TextUnit> => {
  return unit.type === 'text';
};
</file>

<file path="app/types/units/VideoUnit.ts">
import type { Unit } from '..';
import { UnitInterface } from './interfaces';

export interface VideoUnit extends UnitInterface {
  x: number;
  y: number;
  videoId: string;
  displaySize: string;
}

export const isVideoUnit = (unit: Unit): unit is Unit<VideoUnit> => {
  return unit.type === 'video';
};
</file>

<file path="app/types/zenn/Article.ts">
import { ZennUser } from '.';

export type ZennArticle = {
  id: number;
  postType: 'Article';
  title: string;
  slug: string;
  articleType: 'tech' | 'idea';
  emoji: string;
  publishedAt: Date;
  url: string;
};
</file>

<file path="app/types/zenn/index.ts">
export * from './Article';
export * from './User';
</file>

<file path="app/types/zenn/User.ts">
export type ZennUser = {
  id: number;
  username: string;
  name: string;
  avatar_small_url: string;
};
</file>

<file path="app/types/Category.ts">
import type { Blog } from '.';
import type { CategoryStatus } from './enums';

export type Category = {
  id: number;
  code: string;
  status: CategoryStatus;
  sort: number;
  name: string;
  pcid: number;
  indexing: 'on' | 'off';
  path: string;
  blog: Blog;
};
</file>

<file path="app/types/Entry.ts">
import type { Blog, Category, Tag, User, Unit, BlogBlog } from '.';
import type { EntryStatus } from './enums';

export type Entry = {
  id: number;
  code: string;
  sort: number;
  csort: number;
  usort: number;
  status: EntryStatus;
  title: string;
  path: string;
  isNew: boolean;
  createdAt: Date;
  updatedAt?: Date;
  postedAt?: Date;
  startAt?: Date;
  endAt?: Date;
  summary?: string;
  tags?: Tag[];
  category?: Category;
  blog?: Blog;
  user?: User;
  body?: string;
};

export type BlogEntry = Entry & {
  blog?: BlogBlog;
};
</file>

<file path="app/types/index.ts">
export * from './enums';
export * from './units';
export * from './zenn';
export * from './Blog';
export * from './Category';
export * from './Entry';
export * from './Media';
export * from './Tag';
export * from './Unit';
export * from './User';
</file>

<file path="app/types/Media.ts">
import { MediaStatus, MediaType } from './enums';

export type Media = {
  id: number;
  status: MediaStatus;
  path: string;
  thumbnail: string;
  fileName: string;
  imageSize: string;
  fileSize: number;
  type: MediaType;
  extension: string;
  original: string;
  createdAt: Date;
  updatedAt: Date;
  caption: string;
  link: string;
  alt: string;
  page: number;
  focalX: number;
  focalY: number;
  width: number;
  height: number;
  ratio: number;
};
</file>

<file path="app/types/smartphoto.d.ts">
declare module 'smartphoto' {
  interface SmartPhotoOption {
    classNames?: {
      smartPhoto: string;
      smartPhotoClose: string;
      smartPhotoBody: string;
      smartPhotoInner: string;
      smartPhotoContent: string;
      smartPhotoImg: string;
      smartPhotoImgOnMove: string;
      smartPhotoImgElasticMove: string;
      smartPhotoImgWrap: string;
      smartPhotoArrows: string;
      smartPhotoNav: string;
      smartPhotoArrowRight: string;
      smartPhotoArrowLeft: string;
      smartPhotoImgLeft: string;
      smartPhotoImgRight: string;
      smartPhotoList: string;
      smartPhotoListOnMove: string;
      smartPhotoHeader: string;
      smartPhotoCount: string;
      smartPhotoCaption: string;
      smartPhotoDismiss: string;
      smartPhotoLoader: string;
      smartPhotoLoaderWrap: string;
      smartPhotoImgClone: string;
    };
    message?: {
      gotoNextImage: string;
      gotoPrevImage: string;
      closeDialog: string;
    };
    arrows?: boolean;
    nav?: boolean;
    showAnimation?: boolean;
    verticalGravity?: boolean;
    useOrientationApi?: boolean;
    useHistoryApi?: boolean;
    swipeTopToClose?: boolean;
    swipeBottomToClose?: boolean;
    swipeOffset?: number;
    headerHeight?: number;
    footerHeight?: number;
    forceInterval?: number;
    registance?: number;
    loadOffset?: number;
    resizeStyle?: 'fit' | 'cover';
    lazyAttribute?: string;
  }
}
</file>

<file path="app/types/Tag.ts">
export type Tag = {
  name: string;
  path: string;
};
</file>

<file path="app/types/Unit.ts">
import type { UnitType, UnitAlign } from './enums';
import type { UnitInterface } from './units/interfaces';

export type Unit<T extends UnitInterface = UnitInterface> = T & {
  id: number;
  type: UnitType;
  sort: number;
  align: UnitAlign;
  attr: string;
  group: string;
  unitGroup: {
    open: boolean;
    close: boolean;
  };
};
</file>

<file path="app/types/User.ts">
import type { Blog } from '.';
import type { UserAuth, UserStatus } from './enums';

export type User = {
  id: number;
  code: string;
  status: UserStatus;
  sort: number;
  name: string;
  mail: string;
  auth: UserAuth;
  indexing: 'on' | 'off';
  url: string;
  icon: string;
  largeIcon: string;
  createdAt: Date;
  updatedAt: Date;
  blog: Blog;
};
</file>

<file path="app/utils/deleteNewLine.ts">
export default function deleteNewLine(string: string): string {
  return string.replace(/\r?\n/g, '');
}
</file>

<file path="app/utils/encodeUri.ts">
/**
 * RFC 3986 に基づいてURLエンコードを行う
 * @see https://www.rfc-editor.org/rfc/rfc3986
 */
export default function encodeUri(str: string | number | boolean): string {
  return encodeURIComponent(str).replace(
    /[!'()*]/g,
    (match) => `%${match.charCodeAt(0).toString(16)}`,
  );
}
</file>

<file path="app/utils/groupByUnitGroup.ts">
import type { Unit } from '../types';

export default function groupByUnitGroup(units: Unit[]) {
  return units.reduce((arr: (Unit | Unit[])[], current: Unit) => {
    const prev = arr.at(-1);

    if (current.unitGroup.open === true) {
      return [...arr, [current]];
    }

    if (
      prev &&
      Array.isArray(prev) &&
      prev[prev.length - 1].unitGroup.close === false
    ) {
      return [...arr.slice(0, -1), [...prev, current]];
    }

    return [...arr, current];
  }, []);
}
</file>

<file path="app/utils/isDateString.ts">
export default function isDateString(string: string): boolean {
  return !isNaN(Date.parse(string));
}
</file>

<file path="app/utils/isExternalLink.ts">
export default function isExternalLink(url: string) {
  if (!/^(https?)?:/.test(url)) {
    return false;
  }

  if (new RegExp(`${globalThis.location?.hostname}(:\\d+)*`).test(url)) {
    return false;
  }

  return true;
}
</file>

<file path="app/utils/isNumber.ts">
export default function isNumber(value: any): value is number {
  return typeof value === 'number';
}
</file>

<file path="app/utils/isObject.ts">
export default function isObject(
  value: unknown,
): value is Record<string, unknown> {
  return value !== null && typeof value === 'object';
}
</file>

<file path="app/utils/isString.ts">
/**
 * Check string
 *
 * @param {unknown} value
 * @returns {boolean}
 */
export default function isString(value: unknown): value is string {
  return typeof value === 'string';
}
</file>

<file path="app/utils/nl2br.ts">
const newlineRegex = /(\r\n|\r|\n)/g;

export default function nl2br(string: string) {
  if (typeof string !== 'string') {
    return string;
  }

  return string
    .split(newlineRegex)
    .map(function (line, index) {
      if (line.match(newlineRegex)) {
        return '<br />';
      }
      return line;
    })
    .join('');
}
</file>

<file path="app/utils/objToSearchParams.ts">
export default function objToSearchPrams(nextSearchParams: {
  [key: string]: string | string[] | undefined;
}) {
  const searchParams = new URLSearchParams();
  Object.entries(nextSearchParams).forEach(([key, value]) => {
    if (Array.isArray(value)) {
      value.forEach((v) => searchParams.append(key, v));
    } else {
      searchParams.append(key, value as string);
    }
  });
  return searchParams;
}
</file>

<file path="app/utils/range.ts">
export default function range(start: number, end: number, step: number = 1) {
  return Array.from(
    { length: (end - start) / step + 1 },
    (_, i) => start + i * step,
  );
}
</file>

<file path="app/utils/truncate.ts">
export default function truncate(
  string: string,
  length: number,
  end: string = '...',
) {
  return [...string].length <= length
    ? string
    : `${string.substring(0, length)}${end}`;
}
</file>

<file path="app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

.smartphoto {
  @apply !z-[1001];
}
</file>

<file path="app/not-found.tsx">
import Link from 'next/link';
import { Container } from './components';

export default function NotFound() {
  return (
    <section className="bg-white dark:bg-gray-900">
      <Container>
        <div className="mx-auto max-w-screen-sm text-center">
          <h1 className="mb-4 text-7xl font-extrabold tracking-tight text-stone-700 dark:text-white lg:text-9xl">
            404
          </h1>
          <p className="mb-4 text-lg font-light text-stone-500 dark:text-stone-400">
            申し訳ございませんが、お探しのページは存在していないようです。
          </p>
          <Link
            href="/"
            className="my-4 inline-flex rounded-lg bg-stone-700 px-5 py-2.5 text-center text-sm font-medium text-white hover:bg-stone-900 focus:outline-none focus:ring-4 focus:ring-stone-900 dark:focus:ring-stone-900"
          >
            トップページに戻る
          </Link>
        </div>
      </Container>
    </section>
  );
}
</file>

<file path=".lintstagedrc.js">
const path = require('path');

const buildEslintCommand = (filenames) =>
  `next lint --fix --file ${filenames
    .map((f) => path.relative(process.cwd(), f))
    .join(' --file ')}`;

module.exports = {
  '*.{js,jsx,ts,tsx}': [buildEslintCommand, 'prettier --write'],
};
</file>

<file path="postcss.config.js">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="prettier.config.js">
module.exports = {
  printWidth: 80,
  trailingComma: 'all',
  tabWidth: 2,
  semi: true,
  singleQuote: true,
  jsxSingleQuote: false,
  endOfLine: 'lf',
  plugins: [require('prettier-plugin-tailwindcss')],
};
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org/) project bootstrapped with [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/basic-features/font-optimization) to automatically optimize and load Inter, a custom Google Font.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js/) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/deployment) for more details.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es5",
    "downlevelIteration": true,
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules", ".next"]
}
</file>

<file path="app/blog/zenn/routes/ZennArticleIndexRoute.tsx">
import Link from 'next/link';
import {
  Container,
  EmptyState,
  TabList,
  Tab,
  ZennArticleList,
} from '@/app/components';
import { ZennArticle } from '@/app/types';

type Props = {
  articles: ZennArticle[];
  nextPage: number | null;
  page?: number;
};

export default function ZennArticleIndexRoute({
  articles,
  nextPage,
  page = 1,
}: Props) {
  const prevPage = page >= 2 ? page - 1 : null;

  return (
    <Container>
      <main>
        <div>
          <div>
            <div className="flex flex-col gap-10">
              <TabList>
                <Tab>
                  <Link
                    href="/blog/"
                    className="inline-block rounded-t-lg border-b-2 border-transparent p-4 hover:border-gray-300 hover:text-gray-600 dark:hover:text-gray-300"
                  >
                    Blog
                  </Link>
                </Tab>
                <Tab>
                  <Link
                    href="/blog/zenn/"
                    className="inline-block rounded-t-lg border-b-2 border-primary p-4"
                    aria-current="page"
                  >
                    Zenn
                  </Link>
                </Tab>
              </TabList>
              <div>
                {articles.length > 0 ? (
                  <div className="flex flex-col gap-12">
                    <div>
                      <ZennArticleList articles={articles} />
                    </div>
                    <div className="flex justify-end">
                      {prevPage != null && (
                        <Link
                          href={`/blog/zenn/page/${prevPage}`}
                          className="me-3 flex h-10 items-center justify-center rounded-lg border border-gray-300 bg-white px-4 text-base font-medium text-gray-500 hover:bg-gray-100 hover:text-gray-700 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white"
                        >
                          <svg
                            className="me-2 h-3.5 w-3.5 rtl:rotate-180"
                            aria-hidden="true"
                            xmlns="http://www.w3.org/2000/svg"
                            fill="none"
                            viewBox="0 0 14 10"
                          >
                            <path
                              stroke="currentColor"
                              strokeLinecap="round"
                              strokeLinejoin="round"
                              strokeWidth={2}
                              d="M13 5H1m0 0 4 4M1 5l4-4"
                            />
                          </svg>
                          前へ
                        </Link>
                      )}
                      {nextPage != null && (
                        <Link
                          href={`/blog/zenn/page/${nextPage}`}
                          className="flex h-10 items-center justify-center rounded-lg border border-gray-300 bg-white px-4 text-base font-medium text-gray-500 hover:bg-gray-100 hover:text-gray-700 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white"
                        >
                          次へ
                          <svg
                            className="ms-2 h-3.5 w-3.5 rtl:rotate-180"
                            aria-hidden="true"
                            xmlns="http://www.w3.org/2000/svg"
                            fill="none"
                            viewBox="0 0 14 10"
                          >
                            <path
                              stroke="currentColor"
                              strokeLinecap="round"
                              strokeLinejoin="round"
                              strokeWidth={2}
                              d="M1 5h12m0 0L9 1m4 4L9 9"
                            />
                          </svg>
                        </Link>
                      )}
                    </div>
                  </div>
                ) : (
                  <EmptyState />
                )}
              </div>
            </div>
          </div>
        </div>
      </main>
    </Container>
  );
}
</file>

<file path="app/blog/zenn/page.tsx">
import { Metadata } from 'next';
import { getMetadata } from '@/app/api';
import { getZennArticles } from './api';
import ZennArticleIndexRoute from './routes/ZennArticleIndexRoute';

export async function generateMetadata(): Promise<Metadata> {
  return await getMetadata({ blog: 'blog', category: 'zenn' });
}

export default async function ZennArticlesPage() {
  const { articles, nextPage } = await getZennArticles();

  return <ZennArticleIndexRoute articles={articles} nextPage={nextPage} />;
}
</file>

<file path="app/blog/page.tsx">
import { getBlogEntries } from './api';
import { Metadata } from 'next';
import { getMetadata } from '../api';
import BlogIndexRoute from './routes/BlogIndexRoute';

export async function generateMetadata(): Promise<Metadata> {
  return await getMetadata({ blog: 'blog' });
}

export default async function BlogIndexPage() {
  const { entries, pager } = await getBlogEntries();

  const props: React.ComponentProps<typeof BlogIndexRoute> = {
    entries,
    pagination: {
      currentPage: 1,
      previous: pager?.previous,
      pages: pager?.pages || [],
      next: pager?.next,
    },
  };

  return <BlogIndexRoute {...props} />;
}
</file>

<file path="app/components/Badge/Badge.tsx">
import clsx from 'clsx';
import { ComponentPropsWithoutRef, forwardRef } from 'react';

type Props = ComponentPropsWithoutRef<'span'> & {
  as?: React.ElementType;
  chidren?: React.ReactNode;
};

export default forwardRef<HTMLSpanElement, Props>(function Badge(
  { as: Component = 'span', className, children, ...props },
  ref,
) {
  return (
    <Component
      ref={ref}
      className={clsx(
        'rounded bg-yellow-100 px-2.5 py-0.5 text-sm font-medium text-yellow-800 dark:bg-yellow-200',
        className,
      )}
      {...props}
    >
      {children}
    </Component>
  );
});
</file>

<file path="app/components/BlogSearchForm/index.ts">
export { default as BlogSearchForm } from './BlogSearchForm';
</file>

<file path="app/components/ConditionalWrapper/ConditionalWrapper.tsx">
type Props = {
  condition: boolean;
  wrapper: (children: React.ReactNode) => React.ReactElement;
  children: React.ReactNode;
};

export default function ConditionalWrapper({
  condition,
  wrapper,
  children,
}: Props) {
  return <>{condition ? wrapper(children) : children}</>;
}
</file>

<file path="app/components/CopyToClipboard/index.ts">
export { default as CopyToClipboard } from './CopyToClipboard';
</file>

<file path="app/components/CreatedTime/index.ts">
export { default as CreatedTime } from './CreatedTime';
</file>

<file path="app/components/Header/Logo.tsx">
'use client';

import Link from 'next/link';
import Image from 'next/image';
import { isDarkMode, useColorThemeStore } from '@/app/stores/color-theme';
import { useMemo } from 'react';
import { useBrowser } from '@/app/hooks';
import { usePathname } from 'next/navigation';

export default function Logo() {
  const isBrowser = useBrowser();
  const pathname = usePathname();
  const { colorTheme } = useColorThemeStore();
  const logoImagePath = useMemo(() => {
    if (!isBrowser) {
      return '/logo-light.svg';
    }
    return isDarkMode(colorTheme) ? '/logo-dark.svg' : '/logo-light.svg';
  }, [isBrowser, colorTheme]);

  const logoImage = useMemo(
    () => (
      <Link href="/" className="flex items-center">
        <Image
          src={logoImagePath}
          alt="UiDev logo"
          width="105"
          height="30"
          priority
        />
      </Link>
    ),
    [logoImagePath],
  );

  const isHomePage = useMemo(() => pathname === '/', [pathname]);

  if (isHomePage) {
    return <h1>{logoImage}</h1>;
  }

  return <div>{logoImage}</div>;
}
</file>

<file path="app/components/RichLink/index.ts">
export { default as RichLink } from './RichLink';
</file>

<file path="app/components/Spinner/index.ts">
export { default as Spinner } from './Spinner';
</file>

<file path="app/components/Spinner/Spinner.tsx">
import { forwardRef } from 'react';

type Props = React.ComponentPropsWithoutRef<'div'>;

export default forwardRef<HTMLDivElement, Props>(function Spinner(
  { className = 'h-4 w-4', ...rest }: Props,
  ref,
) {
  return (
    <div ref={ref} role="status" className={className} {...rest}>
      <svg
        aria-hidden="true"
        className="animate-spin fill-gray-600 text-gray-200 dark:text-gray-600"
        viewBox="0 0 100 101"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          d="M100 50.5908C100 78.2051 77.6142 100.591 50 100.591C22.3858 100.591 0 78.2051 0 50.5908C0 22.9766 22.3858 0.59082 50 0.59082C77.6142 0.59082 100 22.9766 100 50.5908ZM9.08144 50.5908C9.08144 73.1895 27.4013 91.5094 50 91.5094C72.5987 91.5094 90.9186 73.1895 90.9186 50.5908C90.9186 27.9921 72.5987 9.67226 50 9.67226C27.4013 9.67226 9.08144 27.9921 9.08144 50.5908Z"
          fill="currentColor"
        />
        <path
          d="M93.9676 39.0409C96.393 38.4038 97.8624 35.9116 97.0079 33.5539C95.2932 28.8227 92.871 24.3692 89.8167 20.348C85.8452 15.1192 80.8826 10.7238 75.2124 7.41289C69.5422 4.10194 63.2754 1.94025 56.7698 1.05124C51.7666 0.367541 46.6976 0.446843 41.7345 1.27873C39.2613 1.69328 37.813 4.19778 38.4501 6.62326C39.0873 9.04874 41.5694 10.4717 44.0505 10.1071C47.8511 9.54855 51.7191 9.52689 55.5402 10.0491C60.8642 10.7766 65.9928 12.5457 70.6331 15.2552C75.2735 17.9648 79.3347 21.5619 82.5849 25.841C84.9175 28.9121 86.7997 32.2913 88.1811 35.8758C89.083 38.2158 91.5421 39.6781 93.9676 39.0409Z"
          fill="currentFill"
        />
      </svg>
      <span className="sr-only">Loading...</span>
    </div>
  );
});
</file>

<file path="app/components/TagList/TagList.tsx">
import { Tag } from '@/app/types';
import { Badge, ConditionalWrapper } from '..';
import Link from 'next/link';
import clsx from 'clsx';

type Props = {
  tags: Tag[];
  isLink?: boolean;
};

export default function TagList({ tags = [], isLink = false }: Props) {
  return (
    <ul className="inline-flex flex-wrap gap-x-2">
      {tags.map((tag) => (
        <li key={tag.name}>
          <ConditionalWrapper
            condition={isLink}
            wrapper={(children) => (
              <Link href={tag.path} className="group">
                {children}
              </Link>
            )}
          >
            <Badge
              className={clsx({
                ['group-hover:bg-yellow-200 group-hover:bg-yellow-300']: isLink,
              })}
            >
              #{tag.name}
            </Badge>
          </ConditionalWrapper>
        </li>
      ))}
    </ul>
  );
}
</file>

<file path="app/components/ThemeColorSwitcher/index.ts">
export { default as ThemeColorSwitcher } from './ThemeColorSwitcher';
</file>

<file path="app/components/Unit/Types/QuoteUnit/index.ts">
export { default as QuoteUnit } from './QuoteUnit';
</file>

<file path="app/components/Unit/Types/QuoteUnit/QuoteUnit.tsx">
import { RichLink } from '@/app/components';
import type { Unit, QuoteUnit } from '@/app/types';

export default function QuoteUnit({
  siteName,
  title,
  description,
  image,
  url,
}: Unit<QuoteUnit>) {
  return (
    <div className="not-format my-[1.5em] sm:my-[2em] lg:my-[1.7777778em]">
      <RichLink
        href={url}
        siteName={siteName}
        title={title}
        description={description}
        imageSrc={image}
        target="_blank"
        rel="noopener noreferrer"
      />
    </div>
  );
}
</file>

<file path="app/components/Unit/Types/RichEditorUnit/RichEditorUnit.tsx">
import parse, {
  HTMLReactParserOptions,
  domToReact,
  Element,
  attributesToProps,
  DOMNode,
} from 'html-react-parser';
import type { Unit, RichEditorUnit } from '@/app/types';
import Link from 'next/link';
import { ASSETS_HOST } from '@/app/config/acms';

const options: HTMLReactParserOptions = {
  replace(domNode) {
    if (domNode instanceof Element && domNode.attribs) {
      if (domNode.tagName === 'a') {
        const { href, ...rest } = domNode.attribs;
        return (
          <Link href={href} {...attributesToProps(rest)}>
            {domToReact(domNode.children as DOMNode[], options)}
          </Link>
        );
      }

      if (domNode.tagName === 'img') {
        const { src, alt, ...rest } = domNode.attribs;
        const url = new URL(src, ASSETS_HOST);
        return (
          <a href={url.toString()} className="js-smartphoto">
            {/* eslint-disable-next-line @next/next/no-img-element */}
            <img src={url.toString()} alt={alt} {...attributesToProps(rest)} />
          </a>
        );
      }
    }
  },
};

export default function RichEditorUnit({ html }: Unit<RichEditorUnit>) {
  return <div>{parse(html, options)}</div>;
}
</file>

<file path="app/components/Unit/Types/TextUnit/TextUnit.tsx">
import ReactMarkdown from 'react-markdown';
import rehypeRaw from 'rehype-raw';
import parse, {
  HTMLReactParserOptions,
  domToReact,
  Element,
  attributesToProps,
  DOMNode,
} from 'html-react-parser';
import type { Unit, TextUnit } from '@/app/types';
import { nl2br } from '@/app/utils';
import Link from 'next/link';

const options: HTMLReactParserOptions = {
  replace(domNode) {
    if (domNode instanceof Element && domNode.attribs) {
      if (domNode.tagName === 'a') {
        const { href, ...rest } = domNode.attribs;
        return (
          <Link href={href} {...attributesToProps(rest)}>
            {domToReact(domNode.children as DOMNode[], options)}
          </Link>
        );
      }
    }
  },
};

function getClassName(attr: string) {
  // class="〇〇"を取り出す。
  return attr.trim().substring(6, attr.trim().length - 1) || undefined;
}

function line2List(string: string): React.ReactElement[] {
  return string
    .split(/( |　|\t)*\r?\n/)
    .filter((v) => !!v)
    .map((line, index) => {
      return <li key={index}>{line}</li>;
    });
}

export default function TextUnit({
  attr,
  tag,
  text,
  extendTag,
}: Unit<TextUnit>) {
  if (tag === 'p') {
    return (
      <p id={extendTag || undefined} className={getClassName(attr)}>
        {parse(nl2br(text), options)}
      </p>
    );
  } else if (['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)) {
    const Heading = tag as Extract<
      typeof tag,
      'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6'
    >;
    return (
      <Heading id={extendTag || undefined} className={getClassName(attr)}>
        {parse(nl2br(text), options)}
      </Heading>
    );
  } else if (['ul', 'ol'].includes(tag)) {
    const List = tag as Extract<typeof tag, 'ol' | 'ul'>;
    return <List className={getClassName(attr)}>{line2List(text)}</List>;
  } else if (tag === 'blockquote') {
    return (
      <blockquote className={getClassName(attr)}>
        <p>{parse(nl2br(text), options)}</p>
      </blockquote>
    );
  } else if (tag === 'pre') {
    return (
      <pre>
        <code className={getClassName(attr)}>{text}</code>
      </pre>
    );
  } else if (tag === 'none') {
    return <>{parse(text, options)}</>;
  } else if (tag === 'markdown') {
    return <ReactMarkdown rehypePlugins={[rehypeRaw]}>{text}</ReactMarkdown>;
  } else if (tag === 'wysiwyg') {
    return <>{parse(text, options)}</>;
  }

  return null;
}
</file>

<file path="app/components/Unit/Types/index.ts">
export * from './MediaUnit';
export * from './OpenStreetMapUnit';
export * from './QuoteUnit';
export * from './RichEditorUnit';
export * from './TableUnit';
export * from './TextUnit';
</file>

<file path="app/components/Unit/Unit.tsx">
import {
  isTextUnit,
  isMediaUnit,
  isRichEditorUnit,
  isTableUnit,
  isOpenStreetMapUnit,
  isQuoteUnit,
} from '@/app/types';
import {
  TextUnit,
  MediaUnit,
  RichEditorUnit,
  TableUnit,
  OpenStreetMapUnit,
  QuoteUnit,
} from '@/app/components';
import type { Unit as UnitType } from '@/app/types';

type Props = {
  unit: UnitType;
};

export default function Unit({ unit }: Props) {
  if (isTextUnit(unit)) {
    return <TextUnit {...unit} />;
  }

  if (isMediaUnit(unit)) {
    return <MediaUnit {...unit} />;
  }

  if (isTableUnit(unit)) {
    return <TableUnit {...unit} />;
  }

  if (isRichEditorUnit(unit)) {
    return <RichEditorUnit {...unit} />;
  }

  if (isOpenStreetMapUnit(unit)) {
    return <OpenStreetMapUnit {...unit} />;
  }

  if (isQuoteUnit(unit)) {
    return <QuoteUnit {...unit} />;
  }

  return null;
}
</file>

<file path="app/config/index.ts">
export const BASE_URL = `https://${process.env.DOMAIN}`;
</file>

<file path="app/feed/api/index.ts">
import { BASE_URL } from '@/app/config';
import acmsClient from '@/app/lib/acms';
import { resolveRequestCache } from '@/app/utils';
import { AcmsContext } from '@uidev1116/acms-js-sdk/acmsPath';

export type RssFeedItem = {
  title: string;
  link: string;
  pubDate: Date;
  category: string;
  permalink: string;
  creator: string;
};

export type RssFeed = {
  items: RssFeedItem[];
  lastBuildDate: Date;
};

export async function getRssFeed(
  acmsContext: AcmsContext = {},
): Promise<RssFeed> {
  const { data } = await acmsClient.get(
    { ...acmsContext, api: 'feed' },
    { requestInit: { cache: resolveRequestCache() } },
  );
  const { 'item:loop': items = [], lastBuildDate } = data;
  return {
    items: items.map((item: any) => ({
      title: item.title,
      link: new URL(new URL(item.link).pathname, BASE_URL).toString(),
      pubDate: new Date(item.pubDate),
      category: item.category,
      permalink: new URL(new URL(item.permalink).pathname, BASE_URL).toString(),
      creator: item.creator,
    })),
    lastBuildDate: new Date(lastBuildDate),
  };
}
</file>

<file path="app/hooks/useBlogEntriesSwrMutation/index.ts">
export { default as useBlogEntriesSwrMutation } from './useBlogEntriesSwrMutation';
</file>

<file path="app/hooks/useBlogEntriesSwrMutation/useBlogEntriesSwrMutation.tsx">
import type { Entry } from '@/app/types';
import { encodeUri } from '@/app/utils';
import type { SWRMutationConfiguration } from 'swr/mutation';
import useSWRMutation from 'swr/mutation';

async function fetcher(
  url: string,
  { arg }: { arg: { keyword: string } },
): Promise<Entry[]> {
  const res = await fetch(`${url}?keyword=${encodeUri(arg.keyword)}`);
  if (!res.ok) {
    throw new Error('Failed to fetch data');
  }
  const { entries } = await res.json();
  return entries as Entry[];
}

export default function useBlogEntriesSwrMutation(
  config: SWRMutationConfiguration<Entry[], any> = {},
) {
  const {
    data: entries = [],
    error,
    trigger,
    reset,
    isMutating,
  } = useSWRMutation('/api/blog', fetcher, config);

  return {
    entries,
    error,
    trigger,
    reset,
    isMutating,
  };
}
</file>

<file path="app/hooks/useBrowser/index.ts">
export { default as useBrowser } from './useBrowser';
</file>

<file path="app/hooks/useClipboard/index.ts">
export { default as useClipboard } from './useClipboard';
export type * from './useClipboard';
</file>

<file path="app/hooks/useClipboard/useClipboard.ts">
import { useCallback, useState } from 'react';
import _copy from 'copy-to-clipboard';

export interface UseClipboardOptions {
  format?: string; // MIME type
  onCopy?: (text: string) => void;
}

/**
 * useClipboard
 */
export default function useClipboard({
  onCopy,
  ...copyToClipboardOptions
}: UseClipboardOptions = {}) {
  const [copied, setCopied] = useState(false);

  const copy = useCallback(
    (text: string) => {
      const isCopied = _copy(text, copyToClipboardOptions);
      setCopied(isCopied);
      if (isCopied && onCopy) {
        onCopy(text);
      }
    },
    [copyToClipboardOptions, onCopy],
  );

  const reset = useCallback(() => {
    setCopied(false);
  }, []);

  return { copy, copied, reset };
}
</file>

<file path="app/lib/acms/index.ts">
import { API_HOST, API_KEY } from '@/app/config/acms';
import { createClient } from '@uidev1116/acms-js-sdk';

const acmsClient = createClient({
  baseUrl: API_HOST,
  apiKey: API_KEY,
});

export default acmsClient;
</file>

<file path="app/lib/buildIn/document-outliner.ts">
import DocumentOutliner from 'document-outliner';
import type { ConfigType } from 'document-outliner/lib/type';

const defaultOptions: ConfigType = {
  link: true,
  listType: 'ol',
  listClassName:
    'pl-4 [&.level-1]:relative [&.level-1]:border-l [&.level-1]:border-gray-200 [&.level-1]:dark:border-gray-700 ',
  itemClassName:
    "before:content[''] before:absolute before:w-2.5 before:h-2.5 before:bg-gray-200 before:rounded-full before:mt-2 before:-left-1.5 before:border-2 before:border-white before:dark:border-gray-900 before:dark:bg-gray-700 [.level-1>&]:before:w-3 [.level-1>&]:before:h-3 [.level-1>&]:before:border",
  linkClassName:
    'block focus:ring-gray-200 text-gray-600 dark:text-gray-400 hover:text-black dark:hover:text-white dark:focus:ring-gray-700 text-sm/base my-2 font-medium focus:z-10 focus:outline-none',
  anchorName: 'heading-$1',
  exceptClass: 'js-except',
  levelLimit: 5,
};

export default function setupDocumentOutliner(
  element: Element,
  options: Partial<ConfigType> = {},
) {
  requestAnimationFrame(() => {
    const target = element.getAttribute('data-target');
    if (!target || !document.querySelector(target)) {
      return;
    }
    const outline = new DocumentOutliner(element);
    const overrideConfig: Partial<ConfigType> = {};
    Object.keys(defaultOptions).forEach((key) => {
      let value: any = element.getAttribute(`data-${key}`);
      if (value != null) {
        if (isNaN(value) === false) {
          value = parseInt(value, 10);
        }
        if (value === 'true' || value === 'false') {
          value = value === 'true';
        }
        overrideConfig[key as keyof ConfigType] = value;
      }
    });
    outline.makeList(target, {
      ...defaultOptions,
      ...options,
      ...overrideConfig,
    });
  });
}
</file>

<file path="app/lib/buildIn/index.ts">
import domContentLoaded from 'dom-content-loaded';
import lazyLoadFn from './lazy-load-fn';
import { SmartPhotoOption } from 'smartphoto';
import { ScrollHintOption } from 'scroll-hint';
import { ConfigType } from 'document-outliner/lib/type';

/**
 * ExternalLinks
 * @param context
 */
const externalLinks = (context: Document | Element) => {
  const selector =
    'a:not([target]):not([href^="javascript"]):not([href^="tel"])';
  const targets = context.querySelectorAll<HTMLAnchorElement>(selector);
  const innerlinkPtn = new RegExp(`${window.location.hostname}(:\\d+)*`);
  [].forEach.call(targets, (target: HTMLAnchorElement) => {
    const href = target.getAttribute('href');
    if (!href) {
      return;
    }
    if (innerlinkPtn.exec(href)) {
      return;
    }
    if (!/^(https?)?:/.test(href)) {
      return;
    }
    target.setAttribute('target', '_blank');
    target.setAttribute('rel', 'noopener noreferrer');
  });
};

/**
 * SmartPhoto
 * @param context
 * @param selector
 * @param options
 */
const smartPhoto = (
  context: Document | Element,
  selector = '',
  options: Partial<SmartPhotoOption> = {},
) => {
  domContentLoaded(async () => {
    const querySelector = selector || 'a[data-rel^=SmartPhoto],.js-smartphoto';
    const targets = context.querySelectorAll<HTMLElement>(querySelector);
    if (targets.length > 0) {
      const { default: setup } = await import(
        /* webpackChunkName: "smart-photo" */ './smart-photo'
      );
      setup(targets, options);
    }
  });
};

/**
 * ScrollHint
 * @param context
 */
const scrollHint = (
  context: Document | Element,
  options: Partial<ScrollHintOption> = {},
) => {
  domContentLoaded(async () => {
    if (
      context.querySelector('.js-scroll-hint') ||
      context.querySelector('.js-table-unit-scroll-hint')
    ) {
      const { default: setup } = await import(
        /* webpackChunkName: "scroll-hint" */ './scroll-hint'
      );
      setup('.js-scroll-hint', options);
      setup('.js-table-unit-scroll-hint', { ...options, applyToParents: true });
    }
  });
};

/**
 * OpenStreetMap
 * @param context
 * @param selector
 */
const openStreetMap = (context: Document | Element, selector = '') => {
  domContentLoaded(async () => {
    const querySelector = selector || '.js-open-street-map';
    const targets = context.querySelectorAll<HTMLDivElement>(querySelector);
    if (targets.length > 0) {
      lazyLoadFn(
        querySelector,
        (elm) => elm.getAttribute('data-lazy') === 'true',
        async (item) => {
          const { default: setup } = await import(
            /* webpackChunkName: "open-street-map" */ './open-street-map'
          );
          setup(item);
        },
      );
    }
  });
};

/**
 * DocumentOutliner
 * @param {Element | Document} context
 * @param {string} selector
 * @param {object} options
 */
const documentOutliner = (
  context: Document | Element,
  selector = '.js-outline',
  options: Partial<ConfigType> = {},
) => {
  domContentLoaded(async () => {
    const targets = context.querySelectorAll<HTMLElement>(selector);
    if (targets.length > 0) {
      const { default: setup } = await import(
        /* webpackChunkName: "document-outlier" */ './document-outliner'
      );
      targets.forEach((target) => {
        setup(target, options);
      });
    }
  });
};

export {
  externalLinks,
  smartPhoto,
  scrollHint,
  openStreetMap,
  documentOutliner,
};
</file>

<file path="app/lib/buildIn/open-street-map.ts">
import Leaflet from 'leaflet';
import icon from 'leaflet/dist/images/marker-icon.png';
import icon2x from 'leaflet/dist/images/marker-icon-2x.png';
import iconShadow from 'leaflet/dist/images/marker-shadow.png';
import 'leaflet/dist/leaflet.css';

export default function setupOpenStreetMap(item: HTMLElement) {
  if (item.getAttribute('data-already') === 'true') {
    return;
  }
  item.setAttribute('data-already', 'true');

  const multiple = !!item.getAttribute('data-multiple');
  const lat = parseInt(item.getAttribute('data-lat') as string, 10);
  const lng = parseInt(item.getAttribute('data-lng') as string, 10);
  const zoom = parseInt(item.getAttribute('data-zoom') as string, 10);
  const msg = item.getAttribute('data-msg') || '';
  const markers = item.getAttribute('data-markers');
  const messages = item.getAttribute('data-messages') || '';
  const map = Leaflet.map(item).setView([lat, lng], zoom);

  // @ts-ignore
  delete Leaflet.Icon.Default.prototype._getIconUrl;
  Leaflet.Icon.Default.mergeOptions({
    iconUrl: icon.src,
    iconRetinaUrl: icon2x.src,
    shadowUrl: iconShadow.src,
  });

  Leaflet.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution:
      '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
  }).addTo(map);

  if (multiple && markers) {
    /**
     * Multiple marker
     */
    const points = markers.split('|');
    const panels = messages.split('[[:split:]]');
    points.forEach((point, i) => {
      const latlng = point.split(',');
      if (latlng.length === 2) {
        const view = Leaflet.marker(
          [parseInt(latlng[0].trim(), 10), parseInt(latlng[1].trim(), 10)],
          {
            draggable: false,
          },
        ).addTo(map);
        if (panels[i]) {
          view.bindPopup(panels[i]);
        }
      }
    });
  } else {
    /**
     * Single marker
     */
    const view = Leaflet.marker(map.getCenter(), {
      draggable: false,
    }).addTo(map);
    if (msg) {
      view.bindPopup(msg);
    }
  }
}
</file>

<file path="app/lib/buildIn/scroll-hint.ts">
import ScrollHint, { ScrollHintOption } from 'scroll-hint';
import 'scroll-hint/css/scroll-hint.css';

export default function setupScrollHint(
  elements: string | NodeListOf<HTMLElement>,
  options: Partial<ScrollHintOption> = {},
) {
  const defaultOptions: ScrollHintOption = {
    suggestClass: 'is-active',
    scrollableClass: 'is-scrollable',
    scrollableRightClass: 'is-right-scrollable',
    scrollableLeftClass: 'is-left-scrollable',
    scrollHintClass: 'scroll-hint',
    scrollHintIconClass: 'scroll-hint-icon',
    scrollHintIconAppendClass: 'scroll-hint-icon-white',
    scrollHintIconWrapClass: 'scroll-hint-icon-wrap',
    scrollHintText: 'scroll-hint-text',
    // @ts-ignore
    remainingTime: -1,
    scrollHintBorderWidth: 10,
    enableOverflowScrolling: true,
    suggestiveShadow: false,
    applyToParents: false,
    i18n: {
      scrollable: 'スクロールできます',
    },
  };

  new ScrollHint(elements, Object.assign(defaultOptions, options));
}
</file>

<file path="app/lib/buildIn/smart-photo.ts">
import SmartPhoto, { SmartPhotoOption } from 'smartphoto';
import 'smartphoto/css/smartphoto.min.css';

export default function setupSmartPhoto(
  elements: string | NodeListOf<HTMLElement>,
  options: Partial<SmartPhotoOption> = {},
) {
  const defaultOptions: SmartPhotoOption = {
    classNames: {
      smartPhoto: 'smartphoto',
      smartPhotoClose: 'smartphoto-close',
      smartPhotoBody: 'smartphoto-body',
      smartPhotoInner: 'smartphoto-inner',
      smartPhotoContent: 'smartphoto-content',
      smartPhotoImg: 'smartphoto-img',
      smartPhotoImgOnMove: 'smartphoto-img-onmove',
      smartPhotoImgElasticMove: 'smartphoto-img-elasticmove',
      smartPhotoImgWrap: 'smartphoto-img-wrap',
      smartPhotoArrows: 'smartphoto-arrows',
      smartPhotoNav: 'smartphoto-nav',
      smartPhotoArrowRight: 'smartphoto-arrow-right',
      smartPhotoArrowLeft: 'smartphoto-arrow-left',
      smartPhotoImgLeft: 'smartphoto-img-left',
      smartPhotoImgRight: 'smartphoto-img-right',
      smartPhotoList: 'smartphoto-list',
      smartPhotoListOnMove: 'smartphoto-list-onmove',
      smartPhotoHeader: 'smartphoto-header',
      smartPhotoCount: 'smartphoto-count',
      smartPhotoCaption: 'smartphoto-caption',
      smartPhotoDismiss: 'smartphoto-dismiss',
      smartPhotoLoader: 'smartphoto-loader',
      smartPhotoLoaderWrap: 'smartphoto-loader-wrap',
      smartPhotoImgClone: 'smartphoto-img-clone',
    },
    message: {
      gotoNextImage: '次の画像に移動します',
      gotoPrevImage: '前の画像に移動します',
      closeDialog: '画像ダイアログを閉じます',
    },
    arrows: true,
    nav: true,
    swipeOffset: 100,
    headerHeight: 60,
    footerHeight: 60,
    forceInterval: 10,
    registance: 0.5,
    resizeStyle: 'fit',
    verticalGravity: false,
    useOrientationApi: false,
    useHistoryApi: true,
    lazyAttribute: 'data-src',
  };

  new SmartPhoto(elements, Object.assign(defaultOptions, options));
}
</file>

<file path="app/profile/routes/ProfileRoute.tsx">
import { UnitIndex, Container } from '@/app/components';
import { Entry } from '@/app/types';

type Props = {
  entry: Entry;
};

export default function ProfileRoute({ entry }: Props) {
  return (
    <Container>
      <main className="bg-white dark:bg-gray-900">
        <div className="mx-auto flex max-w-screen-xl justify-between px-4">
          <article className="mx-auto w-full max-w-2xl space-y-4 break-words lg:space-y-6">
            <header className="space-y-4 lg:space-y-6">
              <h1 className="text-3xl font-extrabold leading-tight text-gray-900 dark:text-white lg:text-4xl">
                {entry.title}
              </h1>
            </header>
            {entry.units !== undefined && (
              <div className="format format-sm dark:format-invert sm:format-base lg:format-lg">
                <UnitIndex units={entry.units} />
              </div>
            )}
          </article>
        </div>
      </main>
    </Container>
  );
}
</file>

<file path="app/profile/page.tsx">
import { notFound } from 'next/navigation';
import { getProfileEntry } from './api';
import { Metadata } from 'next';
import { getMetadata } from '../api';
import ProfileRoute from './routes/ProfileRoute';

export async function generateMetadata(): Promise<Metadata> {
  const { openGraph, ...rest } = await getMetadata({ category: 'profile' });
  return {
    ...rest,
    openGraph: {
      ...openGraph,
      type: 'profile',
    },
  };
}

export default async function ProfilePage() {
  const entry = await getProfileEntry();

  if (entry === null) {
    notFound();
  }

  return <ProfileRoute entry={entry} />;
}
</file>

<file path="app/routes/HomeRoute.tsx">
import Link from 'next/link';
import { EmptyState, Container, EntryList } from '@/app/components';
import { Entry } from '../types';

type Props = {
  entries: Entry[];
  blogName: string;
  blogPath: string;
};

export default function HomeRoute({ entries, blogName, blogPath }: Props) {
  if (entries.length === 0) {
    return (
      <Container>
        <main>
          <EmptyState />
        </main>
      </Container>
    );
  }

  return (
    <Container>
      <main>
        <div className="flex flex-col gap-12">
          <div>
            <EntryList entries={entries} />
          </div>
          <div>
            <div className="flex justify-end">
              <Link
                href={blogPath}
                className="flex h-10 items-center justify-center rounded-lg border border-gray-300 bg-white px-4 text-base font-medium text-gray-500 hover:bg-gray-100 hover:text-gray-700 dark:border-gray-700 dark:bg-gray-800 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white"
              >
                {`${blogName}一覧`}
                <svg
                  className="ms-2 h-3.5 w-3.5 rtl:rotate-180"
                  aria-hidden="true"
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 14 10"
                >
                  <path
                    stroke="currentColor"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M1 5h12m0 0L9 1m4 4L9 9"
                  />
                </svg>
              </Link>
            </div>
          </div>
        </div>
      </main>
    </Container>
  );
}
</file>

<file path="app/types/Blog.ts">
export type Blog = {
  id: number;
  code: string;
  name: string;
  path: string;
};

export type RootBlog = Blog & {
  twitterAccount?: string;
  facebookAccount?: string;
  githubAccount?: string;
  youtubeAccount?: string;
  googleAnalytics?: string;
  googleSiteVerification?: string;
  gaId: string;
};

export type BlogBlog = Blog & {
  ogpImageBasePath?: string;
};
</file>

<file path="app/utils/index.ts">
export { default as deleteNewLine } from './deleteNewLine';
export { default as isDateString } from './isDateString';
export { default as isExternalLink } from './isExternalLink';
export { default as groupByUnitGroup } from './groupByUnitGroup';
export { default as isBrowser } from './isBrowser';
export { default as isNumber } from './isNumber';
export { default as isObject } from './isObject';
export { default as isString } from './isString';
export { default as nl2br } from './nl2br';
export { default as noop } from './noop';
export { default as encodeUri } from './encodeUri';
export { default as range } from './range';
export { default as resolveRequestCache } from './resolveRequestCache';
export { default as truncate } from './truncate';
export { default as objToSearchParams } from './objToSearchParams';
</file>

<file path="app/utils/isBrowser.ts">
const isBrowser = typeof window !== 'undefined';
export default isBrowser;
</file>

<file path="app/utils/noop.ts">
const noop = () => {};

export default noop;
</file>

<file path="app/utils/react-nl2br.ts">
import { createElement, type ReactNode } from 'react';

export default function nl2br(text: string): ReactNode[] {
  return text
    .split('\n')
    .map((line, index) => [line, createElement('br', { key: index })])
    .flat()
    .slice(0, -1);
}
</file>

<file path="app/utils/resolveRequestCache.ts">
/**
 * 開発時はキャッシュを無効化する
 */
export default function resolveRequestCache(cache?: RequestInit['cache']) {
  if (process.env.NODE_ENV !== 'production') {
    return 'no-cache';
  }

  return cache;
}
</file>

<file path="app/icon.svg">
<svg width="256" height="256" viewBox="0 0 256 256" fill="none" xmlns="http://www.w3.org/2000/svg">
  <style>
    #circle {
      fill: #000000;
    }

    .character {
      fill: #ffffff;
    }
    @media (prefers-color-scheme: dark) {
      #circle {
        fill: #ffffff;
      }

      .character {
        fill: #000000;
      }
    }
  </style>
  <g clip-path="url(#clip0_18_10)">
    <circle id="circle" cx="128" cy="128" r="128"/>
    <path class="character" d="M94.4079 179.794C100.79 180.675 106.873 180.418 112.881 178.533C122.794 175.422 128.224 167.275 129.121 154.037C129.244 152.228 129.235 150.403 129.235 148.586C129.242 120.347 129.722 92.0908 129.032 63.8752C128.697 50.1747 140.613 44.4741 148.476 47.9488C154.396 50.5645 157.43 55.4424 157.432 62.9935C157.439 93.4791 157.459 123.965 157.423 154.45C157.406 169.287 154.347 182.789 144.868 193.356C136.637 202.53 126.771 207.602 115.676 209.201C103.439 210.965 91.1208 211.258 79.159 207.326C64.0624 202.362 52.1522 192.383 47.5173 173.665C45.8708 167.016 45.3476 159.782 45.2925 152.805C45.0585 123.177 45.6202 93.5335 45.0051 63.9216C44.7149 49.9513 56.8203 44.3806 64.6897 48.0643C70.5831 50.823 73.379 55.4693 73.3815 63.3036C73.3906 91.9708 73.3453 120.638 73.4303 149.305C73.4422 153.333 73.6339 157.492 74.4873 161.358C76.7632 171.671 83.0537 176.964 91.5187 179.134C92.3988 179.36 93.2845 179.555 94.4079 179.794Z"/>
    <path class="character" d="M178.044 157.37C178.044 141.652 178.045 126.254 178.044 110.856C178.044 103.072 180.482 99.0754 186.841 96.9187C191.947 95.1868 196.828 95.9046 201.221 99.6526C203.786 101.84 205.195 104.813 205.194 108.636C205.191 138.469 205.216 168.302 205.167 198.135C205.157 203.927 201.083 208.606 195.11 209.975C191.384 210.829 187.692 210.455 184.298 208.448C180.335 206.106 177.931 202.544 177.997 196.826C178.147 183.783 178.044 170.737 178.044 157.37Z"/>
    <path d="M208.46 73.5389C202.832 82.5743 191.623 85.3631 182.836 80.084C174.389 75.0088 171.554 63.6852 176.547 54.9576C181.47 46.3513 192.728 43.447 201.786 48.4465C210.375 53.187 213.374 64.2336 208.46 73.5389Z" fill="#FDE048"/>
  </g>
  <defs>
    <clipPath id="clip0_18_10">
      <rect width="256" height="256" fill="white"/>
    </clipPath>
  </defs>
</svg>
</file>

<file path="app/page.tsx">
import HomeRoute from '@/app/routes/HomeRoute';
import { getBlogEntries, getMetadata } from '@/app/api';
import { Metadata } from 'next';

export async function generateMetadata(): Promise<Metadata> {
  return await getMetadata();
}

export default async function HomePage() {
  const { indexPath, indexBlogName, entries } = await getBlogEntries();

  return (
    <HomeRoute
      blogPath={indexPath}
      blogName={indexBlogName}
      entries={entries}
    />
  );
}
</file>

<file path="app/sitemap.ts">
import { MetadataRoute } from 'next';
import { getSitemap } from './api';

export default async function sitemap(): Promise<MetadataRoute.Sitemap> {
  return await getSitemap();
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
.claude/
</file>

<file path="eslint.config.js">
const { fixupConfigRules } = require('@eslint/compat');
const { FlatCompat } = require('@eslint/eslintrc');
const js = require('@eslint/js');

const compat = new FlatCompat({
  baseDirectory: __dirname,
  recommendedConfig: js.configs.recommended,
  allConfig: js.configs.all,
});

module.exports = [
  {
    ignores: ['.next/**', 'out/**', 'node_modules/**'],
  },
  ...fixupConfigRules(
    compat.extends(
      'next/core-web-vitals',
      'plugin:jsx-a11y/recommended',
      'prettier',
    ),
  ),
];
</file>

<file path="app/api/blog/draft/route.ts">
import { draftMode } from 'next/headers';
import { redirect } from 'next/navigation';
import { PREVIEW_KEY } from '@/app/config/acms';
import { getBlogEntry } from '@/app/blog/api';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const previewKey = searchParams.get('previewKey');
  const code = searchParams.get('code');

  if (previewKey !== PREVIEW_KEY || code === null) {
    return new Response('Invalid preview key', { status: 401 });
  }

  const entry = await getBlogEntry(code, true);
  if (!entry) {
    return new Response('Invalid entry code', { status: 401 });
  }

  (await draftMode()).enable();

  redirect(entry.path);
}
</file>

<file path="app/blog/page/[page]/page.tsx">
import { range } from '@/app/utils';
import { getBlogEntries } from '../../api';
import { Metadata } from 'next';
import { getMetadata } from '@/app/api';
import BlogIndexRoute from '../../routes/BlogIndexRoute';

export async function generateMetadata(props: {
  params: Promise<{ page: string }>;
}): Promise<Metadata> {
  const params = await props.params;
  return await getMetadata({ blog: 'blog', page: parseInt(params.page, 10) });
}

export async function generateStaticParams() {
  const { pager } = await getBlogEntries();
  return range(pager?.firstPage || 1, pager?.lastPage || 1).map((page) => ({
    page: page.toString(),
  }));
}

export default async function BlogIndexPage(props0: {
  params: Promise<{ page: string }>;
}) {
  const params = await props0.params;
  const page = parseInt(params.page);
  const { entries, pager } = await getBlogEntries({ page });

  const props: React.ComponentProps<typeof BlogIndexRoute> = {
    entries,
    pagination: {
      currentPage: page,
      previous: pager?.previous,
      pages: pager?.pages || [],
      next: pager?.next,
    },
  };

  return <BlogIndexRoute {...props} />;
}
</file>

<file path="app/blog/routes/BlogDetailRoute.tsx">
import { formatISO9075, format } from 'date-fns';
import {
  UnitIndex,
  Container,
  EntryList,
  TagList,
  ShareSocialMedia,
} from '@/app/components';
import { BASE_URL } from '@/app/config';
import { Entry } from '@/app/types';

type Props = {
  entry: Entry;
  relationalEntries: Entry[];
};

export default function BlogDetailRoute({ entry, relationalEntries }: Props) {
  return (
    <>
      <Container>
        <main className="bg-white dark:bg-gray-900">
          <div className="mx-auto flex max-w-screen-xl justify-between px-4">
            <article className="mx-auto w-full max-w-2xl space-y-4 break-words lg:space-y-6">
              <header className="space-y-4 lg:space-y-6">
                <div>
                  <h1 className="text-3xl font-extrabold leading-tight text-gray-900 dark:text-white lg:text-4xl">
                    {entry.title}
                  </h1>
                </div>
                <div className="text-right text-sm text-black dark:text-white">
                  公開日:{' '}
                  <time dateTime={formatISO9075(entry.createdAt)}>
                    {format(entry.createdAt, 'yyyy/MM/dd')}
                  </time>
                </div>
                {entry.tags && entry.tags.length > 0 && (
                  <div>
                    <TagList tags={entry.tags} isLink />
                  </div>
                )}
                <div>
                  <div className="border border-gray-200 bg-white p-4 shadow dark:border-gray-700 dark:bg-gray-900">
                    <h2 className="mb-3 font-bold dark:text-white">目次</h2>
                    <nav
                      className="js-outline-yield break-words"
                      aria-label="目次"
                    />
                  </div>
                </div>
              </header>
              {entry.body !== undefined && (
                <div className="format format-sm dark:format-invert sm:format-base lg:format-lg">
                  <div className="js-outline" data-target=".js-outline-yield">
                    <UnitIndex units={entry.body} />
                  </div>
                </div>
              )}
              <footer>
                <ShareSocialMedia
                  title={entry.title}
                  url={new URL(entry.path, BASE_URL).toString()}
                />
              </footer>
            </article>
          </div>
        </main>
      </Container>
      <aside
        aria-label="関連記事"
        className="bg-gray-50 py-8 dark:bg-gray-800 lg:py-24"
      >
        <div className="mx-auto max-w-screen-xl px-4">
          <h2 className="mb-8 text-2xl font-bold text-gray-900 dark:text-white">
            関連記事
          </h2>
          {relationalEntries.length > 0 ? (
            <EntryList
              className="grid gap-12 sm:grid-cols-2 lg:grid-cols-4"
              entries={relationalEntries}
            />
          ) : (
            <p>関連記事が存在しません</p>
          )}
        </div>
      </aside>
    </>
  );
}
</file>

<file path="app/blog/tag/[tag]/layout.tsx">
import { getAllBlogTags } from '@/app/blog/tag/api';

export async function generateStaticParams() {
  const tags = await getAllBlogTags();
  return tags.map((tag) => ({
    tag,
  }));
}

export default function TagLayout({ children }: { children: React.ReactNode }) {
  return <>{children}</>;
}
</file>

<file path="app/blog/zenn/api/index.ts">
import { ZennArticle } from '@/app/types';

const ZENN_URL = 'https://zenn.dev';
const ZENN_API_HOST = `${ZENN_URL}/api/`;
const ZENN_USER_NAME = 'uidev1116';

export type ZennArticleResponse = {
  articles: ZennArticle[];
  nextPage: number | null;
};

export async function getZennArticles(
  page: number = 1,
): Promise<ZennArticleResponse> {
  const searchParams = new URLSearchParams({
    username: ZENN_USER_NAME,
    order: 'latest',
    count: '10',
    page: page.toString(),
  });
  const endpoint = new URL(`${ZENN_API_HOST}articles/?${searchParams}`);
  const res = await fetch(endpoint, {
    next: {
      revalidate: 3600,
    },
  });

  if (!res.ok) {
    // This will activate the closest `error.js` Error Boundary
    throw new Error('Failed to fetch data');
  }

  const { articles, next_page } = await res.json();

  return {
    articles: articles.map((article: any) => ({
      id: article.id,
      postType: article.post_type,
      title: article.title,
      slug: article.slug,
      publishedAt: new Date(article.published_at),
      articleType: article.article_type,
      emoji: article.emoji,
      url: `${ZENN_URL}${article.path}`,
    })),
    nextPage: next_page,
  };
}
</file>

<file path="app/blog/zenn/page/[page]/page.tsx">
import { Metadata } from 'next';
import { getMetadata } from '@/app/api';
import { getZennArticles } from '../../api';
import { range } from '@/app/utils';
import ZennArticleIndexRoute from '../../routes/ZennArticleIndexRoute';

export async function generateMetadata(props: {
  params: Promise<{ page: string }>;
}): Promise<Metadata> {
  const params = await props.params;
  return await getMetadata({
    blog: 'blog',
    category: 'zenn',
    page: parseInt(params.page, 10),
  });
}

async function getZennArticlesPageAmount() {
  let pageAmount = 1;
  while (true) {
    const { nextPage } = await getZennArticles(pageAmount);
    if (nextPage === null) {
      break;
    }
    pageAmount++;
  }
  return pageAmount;
}

export async function generateStaticParams() {
  const pageAmount = await getZennArticlesPageAmount();

  return range(1, pageAmount).map((page) => ({
    page: page.toString(),
  }));
}

export default async function ZennArticlesPage(props: {
  params: Promise<{ page: string }>;
}) {
  const params = await props.params;
  const page = parseInt(params.page, 10);
  const { articles, nextPage } = await getZennArticles(page);

  return (
    <ZennArticleIndexRoute
      articles={articles}
      nextPage={nextPage}
      page={page}
    />
  );
}
</file>

<file path="app/components/CopyToClipboard/CopyToClipboard.tsx">
import { Children, cloneElement, isValidElement, useCallback } from 'react';
import {
  useClipboard,
  type UseClipboardOptions,
} from '@/app/hooks/useClipboard';

interface CopyToClipboardProps extends UseClipboardOptions {
  children: React.ReactNode;
  text: string;
}

const CopyToClipboard = ({
  children,
  text,
  ...options
}: CopyToClipboardProps) => {
  const { copy } = useClipboard(options);
  const handleClick = useCallback(
    (event: React.MouseEvent) => {
      const element = Children.only(children);
      copy(text);

      // Bypass onClick if it was present
      if (
        isValidElement(element) &&
        element.props &&
        // @ts-expect-error onClick is not typed
        typeof element.props.onClick === 'function'
      ) {
        // @ts-expect-error onClick is not typed
        element.props.onClick(event);
      }
    },
    [copy, children, text],
  );

  const element = Children.only(children);
  if (!isValidElement(element)) {
    return null;
  }

  // @ts-expect-error onClick is not typed
  return cloneElement(element, { ...element.props, onClick: handleClick });
};

export default CopyToClipboard;
</file>

<file path="app/components/ShareSocialMedia/ShareSocialMedia.tsx">
'use client';

import { useState } from 'react';
import { CopyToClipboard } from '@/app/components/CopyToClipboard';

type Props = {
  title: string;
  url: string;
};

export default function ShareSocialMedia({ title, url }: Props) {
  const [isCopied, setIsCopied] = useState(false);
  function handleCopy() {
    setIsCopied(true);
    setTimeout(() => setIsCopied(false), 2000);
  }
  return (
    <aside aria-label="Share social media">
      <a
        href={`https://twitter.com/intent/tweet?${new URLSearchParams({
          text: title,
          url,
        })}`}
        className="hover:text-primary-700 mr-2 inline-flex items-center rounded-lg border border-gray-200 bg-white px-3 py-2 text-xs font-medium text-gray-900 no-underline hover:bg-gray-100 focus:z-10 focus:outline-none focus:ring-4 focus:ring-gray-200 dark:border-gray-600 dark:bg-gray-800 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white dark:focus:ring-gray-700"
        target="_blank"
        rel="noopener noreferrer"
      >
        <svg
          className="mr-2 h-[16px] w-[16px]"
          aria-hidden="true"
          xmlns="http://www.w3.org/2000/svg"
          fill="currentColor"
          viewBox="0 0 20 20"
        >
          <path
            fill="currentColor"
            d="M12.186 8.672 18.743.947h-2.927l-5.005 5.9-4.44-5.9H0l7.434 9.876-6.986 8.23h2.927l5.434-6.4 4.82 6.4H20L12.186 8.672Zm-2.267 2.671L8.544 9.515 3.2 2.42h2.2l4.312 5.719 1.375 1.828 5.731 7.613h-2.2l-4.699-6.237Z"
          />
        </svg>{' '}
        Share
      </a>
      <a
        href={`https://www.facebook.com/sharer/sharer.php?${new URLSearchParams(
          { u: url },
        )}`}
        className="hover:text-primary-700 mr-2 inline-flex items-center rounded-lg border border-gray-200 bg-white px-3 py-2 text-xs font-medium text-gray-900 no-underline hover:bg-gray-100 focus:z-10 focus:outline-none focus:ring-4 focus:ring-gray-200 dark:border-gray-600 dark:bg-gray-800 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white dark:focus:ring-gray-700"
        target="_blank"
        rel="noopener noreferrer"
      >
        <svg
          className="mr-2 h-[16px] w-[16px]"
          fill="currentColor"
          aria-hidden="true"
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 512 512"
        >
          <path d="M504 256C504 119 393 8 256 8S8 119 8 256c0 123.78 90.69 226.38 209.25 245V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.28c-30.8 0-40.41 19.12-40.41 38.73V256h68.78l-11 71.69h-57.78V501C413.31 482.38 504 379.78 504 256z" />
        </svg>{' '}
        Share
      </a>
      <CopyToClipboard text={url} onCopy={handleCopy}>
        <button
          type="button"
          className="hover:text-primary-700 inline-flex items-center rounded-lg border border-gray-200 bg-white px-3 py-2 text-xs font-medium text-gray-900 no-underline hover:bg-gray-100 focus:z-10 focus:outline-none focus:ring-4 focus:ring-gray-200 dark:border-gray-600 dark:bg-gray-800 dark:text-gray-400 dark:hover:bg-gray-700 dark:hover:text-white dark:focus:ring-gray-700"
        >
          {isCopied ? (
            <>
              <svg
                className="mr-2 h-[16px] w-[16px]"
                aria-hidden="true"
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 16 12"
              >
                <path
                  stroke="currentColor"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth="2"
                  d="M1 5.917 5.724 10.5 15 1.5"
                />
              </svg>{' '}
              URL copied!
            </>
          ) : (
            <>
              <svg
                className="mr-2 h-[16px] w-[16px]"
                aria-hidden="true"
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 18 20"
              >
                <path
                  stroke="currentColor"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth="2"
                  d="m7.708 2.292.706-.706A2 2 0 0 1 9.828 1h6.239A.97.97 0 0 1 17 2v12a.97.97 0 0 1-.933 1H15M6 5v4a1 1 0 0 1-1 1H1m11-4v12a.97.97 0 0 1-.933 1H1.933A.97.97 0 0 1 1 18V9.828a2 2 0 0 1 .586-1.414l2.828-2.828A2 2 0 0 1 5.828 5h5.239A.97.97 0 0 1 12 6Z"
                />
              </svg>{' '}
              Copy URL
            </>
          )}
        </button>
      </CopyToClipboard>
    </aside>
  );
}
</file>

<file path="app/components/Unit/Types/TableUnit/TableUnit.tsx">
import parse, {
  HTMLReactParserOptions,
  domToReact,
  Element,
  attributesToProps,
  DOMNode,
} from 'html-react-parser';
import type { Unit, TableUnit } from '@/app/types';

const options: HTMLReactParserOptions = {
  replace(domNode) {
    if (domNode instanceof Element && domNode.attribs) {
      if (domNode.tagName === 'table') {
        return (
          <table {...attributesToProps(domNode.attribs)}>
            <tbody>{domToReact(domNode.children as DOMNode[], options)}</tbody>
          </table>
        );
      }
    }
  },
};

export default function TableUnit({ table }: Unit<TableUnit>) {
  return (
    <div>
      <div className="my-[1.5em] overflow-x-auto sm:my-[2em] lg:my-[1.7777778em]">
        {parse(table, options)}
      </div>
    </div>
  );
}
</file>

<file path="app/feed/route.ts">
import { Feed } from 'feed';
import { getOgp } from '../api';
import { deleteNewLine, truncate } from '../utils';
import { BASE_URL } from '../config';
import { getRssFeed } from './api';
import { MEDIA_BASE_URL } from '../config/acms';

export async function GET() {
  const [ogp, rss] = await Promise.all([getOgp(), getRssFeed()]);

  const feed = new Feed({
    title: ogp.title,
    description: deleteNewLine(truncate(ogp.description, 350)),
    id: BASE_URL,
    link: BASE_URL,
    image: ogp.image?.path
      ? new URL(ogp.image.path, MEDIA_BASE_URL).toString()
      : undefined,
    copyright: '© 2023 blog.uidev.jp. All Rights Reserved.',
    updated: rss.lastBuildDate,
    generator: 'a-blog cms',
    author: {
      name: 'uidev1116',
      email: 'uidev1116@gmail.com',
      link: 'https://blog.uidev.jp/profile/',
    },
  });

  rss.items.forEach((item) => {
    feed.addItem({
      title: item.title,
      id: item.link,
      link: item.link,
      ...(item.category ? { category: [{ name: item.category }] } : {}),
      author: [
        {
          name: item.creator,
          email: 'uidev1116@gmail.com',
          link: 'https://blog.uidev.jp/profile/',
        },
      ],
      date: item.pubDate,
    });
  });

  return new Response(feed.rss2(), {
    headers: {
      'Content-Type': 'application/xml; charset=utf-8',
    },
  });
}
</file>

<file path="app/hooks/useBrowser/useBrowser.ts">
import { useEffect, useState } from 'react';

export default function useBrowser() {
  const [isBrowser, setIsBrowser] = useState(false);
  useEffect(() => {
    setIsBrowser(true);
  }, [setIsBrowser]);

  return isBrowser;
}
</file>

<file path="app/profile/api/index.ts">
import acmsClient from '@/app/lib/acms';
import type { Entry } from '@/app/types';
import { resolveRequestCache } from '@/app/utils';

export async function getProfileEntry(): Promise<Entry | null> {
  const { data } = await acmsClient.get(
    {
      category: 'profile',
      api: 'body_detail',
    },
    { requestInit: { cache: resolveRequestCache() } },
  );

  const { items: entries = [] } = data;

  if (!entries.length) {
    return null;
  }

  return {
    id: entries[0].eid,
    code: entries[0].ecd,
    status: entries[0].status,
    sort: entries[0].sort,
    csort: entries[0].csort,
    usort: entries[0].usort,
    title: entries[0].title,
    path: new URL(entries[0].url).pathname,
    isNew: entries[0].isNew,
    createdAt: new Date(entries[0].datetime),
    updatedAt: new Date(entries[0].updatedAt),
    postedAt: new Date(entries[0].createdAt),
    startAt: new Date(entries[0].publishStartAt),
    endAt: new Date(entries[0].publishEndAt),
    summary: entries[0].summary || '',
    body: entries[0].body,
  };
}
</file>

<file path="public/logo-dark.svg">
<svg width="105" height="30" viewBox="0 0 105 30" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M41.5301 28.9742C39.7467 27.9734 38.8788 26.4704 38.878 24.4631C38.8755 18.1627 38.8714 11.8623 38.88 5.56191C38.8837 2.8337 40.8872 0.72123 43.6168 0.680806C46.5216 0.637784 49.434 0.606773 52.3323 0.768069C55.5458 0.946905 58.478 2.00352 60.7546 4.42677C62.5251 6.31141 63.4114 8.64793 63.8888 11.1534C64.5573 14.6622 64.4618 18.1408 63.2672 21.53C61.6443 26.1347 58.4001 28.7504 53.5722 29.336C52.8246 29.4267 52.0667 29.4616 51.3131 29.4664C48.8331 29.4822 46.3519 29.5096 43.8732 29.4502C43.1025 29.4317 42.3379 29.1511 41.5301 28.9742ZM55.199 22.8022C56.0715 22.1685 56.7007 21.3315 57.0875 20.3357C58.3837 16.9982 58.3284 13.6289 57.1506 10.2836C56.392 8.12886 54.8294 6.72374 52.5868 6.44125C50.523 6.18128 48.417 6.21001 46.3298 6.21352C45.3644 6.21514 44.9673 6.76179 44.9427 7.79998C44.9177 8.8527 44.9349 9.90645 44.9349 10.9598C44.9348 14.6853 44.9283 18.411 44.9389 22.1365C44.9428 23.5345 45.3733 23.958 46.7446 23.9655C48.1978 23.9735 49.651 23.9711 51.1042 23.9664C52.5457 23.9618 53.9009 23.6318 55.199 22.8022Z" fill="white"/>
<path d="M71.1978 9.91368C73.4658 8.94584 75.7748 8.83624 78.0664 9.48091C81.3464 10.4037 82.9019 12.9205 83.6042 16.0692C83.809 16.9875 83.9097 17.9652 83.8431 18.9002C83.7504 20.2028 82.6688 21.225 81.3626 21.2559C78.4187 21.3255 75.4727 21.3011 72.5275 21.3147C72.2988 21.3158 72.07 21.3148 71.8429 21.3148C71.7921 23.6946 73.3679 25.3615 75.6601 25.4786C77.1519 25.5549 78.5416 25.2604 79.8508 24.5488C79.9697 24.4842 80.0936 24.4292 80.2151 24.3694C81.2071 23.8809 82.0917 23.9605 82.7426 24.5969C83.4467 25.2855 83.6696 26.4406 83.2508 27.3531C82.9038 28.1092 82.3267 28.636 81.5717 28.9735C79.7818 29.7735 77.8865 30.05 75.9592 29.9446C74.6565 29.8733 73.325 29.725 72.0779 29.3622C69.7878 28.6959 68.1971 27.1067 67.3117 24.9028C65.7602 21.0405 65.6606 17.173 67.5785 13.3795C68.3683 11.8174 69.5675 10.6632 71.1978 9.91368ZM75.5259 13.487C73.3942 13.3498 72.0859 14.9086 71.9005 17.1369C73.8352 17.1369 75.7665 17.1404 77.6978 17.1352C78.5092 17.1331 78.7686 16.7952 78.6033 15.9867C78.3124 14.5632 77.2262 13.6519 75.5259 13.487Z" fill="white"/>
<path d="M10.6211 24.4088C11.9932 24.5694 13.3007 24.5227 14.5923 24.1787C16.7233 23.6112 17.8906 22.1249 18.0834 19.7098C18.1097 19.3798 18.1078 19.0469 18.1079 18.7153C18.1093 13.5635 18.2125 8.40857 18.0642 3.26104C17.9922 0.761573 20.5537 -0.278431 22.2441 0.355479C23.5166 0.832675 24.169 1.72259 24.1694 3.10019C24.1709 8.66186 24.1751 14.2235 24.1675 19.7852C24.1638 22.4919 23.5061 24.9552 21.4684 26.8829C19.6991 28.5567 17.5781 29.482 15.1931 29.7737C12.5626 30.0955 9.91451 30.149 7.3431 29.4315C4.09782 28.5261 1.5375 26.7054 0.54115 23.2906C0.187203 22.0776 0.0747335 20.7579 0.0628857 19.485C0.0125848 14.0799 0.13332 8.67177 0.001101 3.2695C-0.0612775 0.720813 2.54099 -0.295474 4.23267 0.376558C5.49955 0.879839 6.10058 1.72749 6.10112 3.15676C6.10309 8.38668 6.09335 13.6166 6.1116 18.8465C6.11417 19.5813 6.15538 20.34 6.33883 21.0455C6.82808 22.9269 8.18034 23.8925 10 24.2884C10.1892 24.3296 10.3796 24.3651 10.6211 24.4088Z" fill="white"/>
<path d="M96.7664 19.6055C97.6945 16.7329 98.5994 13.9012 99.5371 11.0806C100.11 9.35609 102.151 8.60908 103.722 9.51168C104.831 10.1482 105.272 11.1753 104.831 12.5705C104.275 14.3271 103.594 16.0443 102.951 17.7721C101.826 20.7927 100.698 23.8126 99.552 26.8251C98.4458 29.732 95.3211 30.8467 92.8296 29.2403C92.0024 28.707 91.4215 27.956 91.0759 27.0449C89.3268 22.4337 87.5944 17.816 85.8599 13.1992C85.7851 13.0002 85.7426 12.7883 85.6922 12.5806C85.2959 10.9487 85.8747 9.74652 87.2699 9.2998C88.8515 8.7934 90.4429 9.50248 90.9752 11.0131C91.543 12.6246 92.049 14.2581 92.5802 15.8826C93.4314 18.4862 94.2809 21.0903 95.1322 23.6939C95.1675 23.8019 95.2141 23.9061 95.2985 24.1224C95.8067 22.5646 96.2819 21.1078 96.7664 19.6055Z" fill="white"/>
<path d="M28.6004 20.3179C28.6004 17.4503 28.6005 14.6412 28.6004 11.8321C28.6004 10.412 29.1245 9.68282 30.4914 9.28935C31.589 8.97338 32.6382 9.10435 33.5827 9.78812C34.134 10.1872 34.4369 10.7296 34.4368 11.4271C34.436 16.8697 34.4414 22.3123 34.4308 27.7549C34.4288 28.8116 33.5529 29.6652 32.269 29.9148C31.4681 30.0706 30.6744 30.0024 29.9447 29.6364C29.0929 29.209 28.576 28.5593 28.5902 27.5161C28.6225 25.1366 28.6004 22.7564 28.6004 20.3179Z" fill="white"/>
<path d="M34.7718 5.67077C33.6221 7.53132 31.332 8.10559 29.5369 7.01853C27.8111 5.97344 27.232 3.6417 28.2519 1.84454C29.2577 0.0723485 31.5578 -0.525705 33.4084 0.503774C35.1631 1.47993 35.7758 3.75463 34.7718 5.67077Z" fill="#FDE048"/>
<path d="M45.4425 7.81183L45.4425 7.81183C45.4537 7.33904 45.5502 7.0784 45.667 6.93883C45.7664 6.81997 45.944 6.71417 46.3306 6.71352C46.4968 6.71324 46.6627 6.71281 46.8285 6.71238C48.757 6.70737 50.6595 6.70242 52.5242 6.93733L52.5867 6.44125L52.5242 6.93733C54.5566 7.19334 55.9754 8.4512 56.679 10.4497C57.8208 13.6928 57.8705 16.9385 56.6214 20.1547C56.2706 21.0577 55.7045 21.8137 54.8848 22.4152C53.7141 23.1543 52.4587 23.462 51.1026 23.4664C49.6498 23.4711 48.1983 23.4734 46.7473 23.4655C46.081 23.4619 45.8129 23.3502 45.6838 23.2202C45.5538 23.0892 45.4408 22.815 45.4388 22.1351C45.4311 19.4197 45.4325 16.7046 45.4338 13.9886C45.4343 12.9792 45.4348 11.9696 45.4349 10.9598C45.4349 10.6489 45.4334 10.3402 45.432 10.0329C45.4285 9.28813 45.425 8.55157 45.4425 7.81183Z" stroke="black"/>
</svg>
</file>

<file path="public/logo-light.svg">
<svg width="105" height="30" viewBox="0 0 105 30" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M41.5301 28.9742C39.7466 27.9734 38.8787 26.4704 38.878 24.4631C38.8755 18.1627 38.8713 11.8623 38.88 5.56191C38.8837 2.8337 40.8872 0.72123 43.6168 0.680806C46.5216 0.637784 49.434 0.606773 52.3323 0.768069C55.5458 0.946905 58.478 2.00352 60.7545 4.42677C62.5251 6.31141 63.4114 8.64793 63.8887 11.1534C64.5573 14.6622 64.4618 18.1408 63.2672 21.53C61.6443 26.1347 58.4001 28.7504 53.5722 29.336C52.8246 29.4267 52.0666 29.4616 51.3131 29.4664C48.833 29.4822 46.3519 29.5096 43.8731 29.4502C43.1024 29.4317 42.3379 29.1511 41.5301 28.9742ZM55.199 22.8022C56.0714 22.1685 56.7007 21.3315 57.0874 20.3357C58.3837 16.9982 58.3284 13.6289 57.1506 10.2836C56.3919 8.12886 54.8293 6.72374 52.5867 6.44125C50.523 6.18128 48.417 6.21001 46.3298 6.21352C45.3644 6.21514 44.9673 6.76179 44.9427 7.79998C44.9177 8.8527 44.9349 9.90645 44.9349 10.9598C44.9347 14.6853 44.9282 18.411 44.9388 22.1365C44.9428 23.5344 45.3733 23.958 46.7446 23.9655C48.1977 23.9735 49.651 23.9711 51.1042 23.9664C52.5457 23.9618 53.9009 23.6318 55.199 22.8022Z" fill="black"/>
<path d="M71.1978 9.91368C73.4658 8.94584 75.7748 8.83624 78.0664 9.48091C81.3464 10.4037 82.9019 12.9205 83.6042 16.0692C83.809 16.9875 83.9097 17.9653 83.8431 18.9002C83.7504 20.2028 82.6688 21.225 81.3626 21.2559C78.4187 21.3255 75.4727 21.3011 72.5275 21.3147C72.2988 21.3158 72.07 21.3148 71.8429 21.3148C71.7921 23.6946 73.3679 25.3615 75.6601 25.4786C77.1519 25.5549 78.5416 25.2604 79.8508 24.5488C79.9697 24.4842 80.0936 24.4292 80.2151 24.3694C81.2071 23.8809 82.0917 23.9605 82.7426 24.5969C83.4467 25.2855 83.6696 26.4406 83.2508 27.3531C82.9038 28.1092 82.3267 28.636 81.5717 28.9735C79.7818 29.7735 77.8865 30.05 75.9592 29.9446C74.6565 29.8733 73.325 29.725 72.0779 29.3622C69.7878 28.6959 68.1971 27.1067 67.3117 24.9028C65.7602 21.0405 65.6606 17.173 67.5785 13.3795C68.3683 11.8174 69.5675 10.6632 71.1978 9.91368ZM75.5259 13.487C73.3942 13.3498 72.0859 14.9086 71.9005 17.1369C73.8352 17.1369 75.7665 17.1404 77.6978 17.1353C78.5092 17.1331 78.7686 16.7952 78.6033 15.9867C78.3124 14.5632 77.2262 13.6519 75.5259 13.487Z" fill="black"/>
<path d="M10.6211 24.4088C11.9932 24.5694 13.3007 24.5227 14.5923 24.1787C16.7233 23.6112 17.8906 22.1249 18.0834 19.7098C18.1097 19.3798 18.1078 19.0469 18.1079 18.7153C18.1093 13.5635 18.2125 8.40857 18.0642 3.26104C17.9922 0.761573 20.5537 -0.278431 22.2441 0.355479C23.5166 0.832675 24.169 1.72259 24.1694 3.10019C24.1709 8.66186 24.1751 14.2235 24.1675 19.7852C24.1638 22.4919 23.5061 24.9552 21.4684 26.8829C19.6991 28.5567 17.5781 29.482 15.1931 29.7737C12.5626 30.0955 9.91451 30.149 7.3431 29.4315C4.09782 28.5261 1.5375 26.7054 0.54115 23.2906C0.187203 22.0776 0.0747335 20.7579 0.0628857 19.485C0.0125848 14.0799 0.13332 8.67177 0.001101 3.2695C-0.0612775 0.720813 2.54099 -0.295474 4.23267 0.376558C5.49955 0.879839 6.10058 1.72749 6.10112 3.15676C6.10309 8.38668 6.09335 13.6166 6.1116 18.8465C6.11417 19.5813 6.15538 20.34 6.33883 21.0455C6.82808 22.9269 8.18034 23.8925 10 24.2884C10.1892 24.3296 10.3796 24.3651 10.6211 24.4088Z" fill="black"/>
<path d="M96.7664 19.6055C97.6945 16.7329 98.5994 13.9012 99.5371 11.0806C100.11 9.35609 102.151 8.60908 103.722 9.51168C104.831 10.1482 105.272 11.1753 104.831 12.5705C104.275 14.3271 103.594 16.0443 102.951 17.7721C101.826 20.7927 100.698 23.8126 99.552 26.8251C98.4458 29.732 95.3211 30.8467 92.8296 29.2403C92.0024 28.707 91.4215 27.956 91.0759 27.0449C89.3267 22.4337 87.5944 17.816 85.8599 13.1992C85.7851 13.0002 85.7426 12.7883 85.6922 12.5806C85.2959 10.9487 85.8747 9.74652 87.2699 9.2998C88.8515 8.7934 90.4429 9.50248 90.9752 11.0131C91.543 12.6246 92.049 14.2581 92.5802 15.8826C93.4314 18.4862 94.2809 21.0903 95.1322 23.6939C95.1675 23.8019 95.2141 23.9061 95.2985 24.1224C95.8067 22.5646 96.2819 21.1078 96.7664 19.6055Z" fill="black"/>
<path d="M28.6004 20.3179C28.6004 17.4503 28.6005 14.6412 28.6004 11.8321C28.6003 10.412 29.1245 9.68282 30.4913 9.28935C31.589 8.97338 32.6382 9.10435 33.5827 9.78812C34.1339 10.1872 34.4368 10.7296 34.4367 11.4271C34.436 16.8697 34.4413 22.3123 34.4308 27.7549C34.4287 28.8116 33.5529 29.6651 32.269 29.9148C31.468 30.0706 30.6744 30.0024 29.9447 29.6364C29.0928 29.209 28.5759 28.5593 28.5901 27.5161C28.6225 25.1366 28.6004 22.7564 28.6004 20.3179Z" fill="black"/>
<path d="M34.7718 5.67077C33.6221 7.53132 31.332 8.10559 29.5369 7.01853C27.8111 5.97344 27.232 3.6417 28.2519 1.84454C29.2577 0.0723485 31.5578 -0.525705 33.4084 0.503774C35.1631 1.47993 35.7758 3.75463 34.7718 5.67077Z" fill="#FDE048"/>
<path d="M45.4425 7.81183L45.4425 7.81183C45.4537 7.33904 45.5502 7.0784 45.667 6.93883C45.7664 6.81997 45.944 6.71417 46.3306 6.71352C46.4968 6.71324 46.6627 6.71281 46.8285 6.71238C48.757 6.70737 50.6595 6.70242 52.5242 6.93733L52.5867 6.44125L52.5242 6.93733C54.5566 7.19334 55.9754 8.4512 56.679 10.4497C57.8208 13.6928 57.8705 16.9385 56.6214 20.1547C56.2706 21.0577 55.7045 21.8137 54.8848 22.4152C53.7141 23.1543 52.4587 23.462 51.1026 23.4664C49.6498 23.4711 48.1983 23.4734 46.7473 23.4655C46.081 23.4619 45.8129 23.3502 45.6838 23.2202C45.5538 23.0892 45.4408 22.815 45.4388 22.1351C45.4311 19.4197 45.4325 16.7046 45.4338 13.9886C45.4343 12.9792 45.4348 11.9696 45.4349 10.9598C45.4349 10.6489 45.4334 10.3402 45.432 10.0329C45.4285 9.28813 45.425 8.55157 45.4425 7.81183Z" stroke="white"/>
</svg>
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Language Preference
**IMPORTANT: Always respond in Japanese (日本語) for all interactions in this project.**

## Development Commands

### Essential Commands
- `npm run dev` - Start development server (runs on port 3000 with UTC timezone)
- `npm run build` - Build production application
- `npm run start` - Start production server
- `npm run lint` - Run ESLint checks
- `npm run test` - Run tests (Note: Vitest dependency needs to be installed)

### Code Quality
- ESLint configuration includes Next.js core web vitals, JSX a11y, and Prettier
- Use `npm run lint` before committing changes
- TypeScript strict mode is enabled
- Husky pre-commit hooks are configured

### Node.js Version
- Project uses Node.js 22.19.0 (managed via Volta)

## Architecture Overview

### Framework & Technology Stack
- **Next.js 14** with App Router (app directory structure)
- **TypeScript** with strict mode
- **Tailwind CSS** for styling with Flowbite components
- **ACMS SDK** (`@uidev1116/acms-js-sdk`) for CMS integration
- **SWR** for data fetching and caching

### Project Structure

#### Core Directories
- `app/` - Next.js App Router pages and components (primary structure)
- `app/components/` - Reusable React components with index.ts barrel exports
- `app/types/` - TypeScript type definitions organized by domain
- `app/lib/` - Library integrations (ACMS client, build-in scripts, fonts)
- `app/utils/` - Utility functions
- `app/hooks/` - Custom React hooks
- `app/stores/` - React Context providers (currently color theme management)

#### Key Components Architecture
- **Unit System**: Flexible content unit system in `app/components/Unit/Types/` supporting various content types (Text, Media, Table, OpenStreetMap, RichEditor)
- **Card Components**: Composable card system with Header, Body, Footer
- **Layout Components**: Header, Footer, Container with navigation integration
- **Theme System**: Dark/light mode with localStorage persistence and system preference detection

### Data Layer

#### ACMS Integration
- Central API client in `app/lib/acms/index.ts`
- Main API functions in `app/api/index.ts`:
  - `getBlogEntries()` - Fetch blog post listings
  - `getGlobalNavigation()` / `getFooterNavigation()` - Navigation data
  - `getRootBlog()` - Site configuration
  - `getOgp()` / `getMetadata()` - SEO metadata generation
- Request caching via `resolveRequestCache()` utility

#### Environment Configuration
- `DOMAIN` - Site domain for base URL generation
- `ACMS_ASSETS_HOST` - Asset hosting configuration
- `API_HOST` / `API_KEY` - ACMS API configuration

### Routing Structure
- Blog listing: `/blog` with pagination `/blog/page/[page]`
- Individual posts: `/blog/[code]`
- Tag filtering: `/blog/tag/[tag]` with pagination
- Search: `/blog/search` with pagination
- Zenn articles: `/blog/zenn` with pagination
- Profile: `/profile`

### Content Management
- **Unit-based Content**: Content is structured using a flexible unit system supporting various types (text, media, tables, maps)
- **Type Safety**: Comprehensive TypeScript types for all content structures
- **SEO**: Automated metadata generation with OpenGraph and Twitter Card support

### Styling Approach
- **Tailwind CSS** with custom configuration
- **Flowbite** component library integration
- **Dark Mode**: System-wide theme switching with persistence
- **Responsive Design**: Mobile-first approach

### Third-Party Integrations
- **Maps**: Leaflet for OpenStreetMap integration
- **Photo Galleries**: SmartPhoto for image viewing
- **Progress Indicators**: NProgress for page transitions
- **Analytics**: Google Analytics integration via Next.js third-parties
- **RSS Feeds**: Feed generation capabilities

### Development Practices
- **Component Organization**: Each component has its own directory with index.ts for clean imports
- **Type Organization**: Types organized by domain in separate files
- **Path Aliases**: `@/*` maps to project root for clean imports
- **Code Splitting**: Automatic with Next.js App Router

## Important Notes

### CMS Integration
This project integrates heavily with ACMS (A-CMS) headless CMS. All content fetching goes through the ACMS SDK client configured in `app/lib/acms/index.ts`.

### Time Zone Handling
Development server runs in UTC timezone (`TZ='Etc/UTC'`) - ensure consistency when working with dates.

### Build Configuration
- Next.js configured with trailing slashes and specific image remote patterns
- TypeScript with bundler module resolution
- Automatic font optimization via `next/font`

### State Management
Currently uses React Context for theme management. SWR handles server state caching.
</file>

<file path="next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: process.env.ACMS_ASSETS_HOST,
      },
    ],
  },
  async redirects() {
    return [
      // Basic redirect
      {
        source: '/blog/entry-106.html',
        destination: '/blog/ablogcms-next-rss-feed.html',
        permanent: true,
      },
    ];
  },
  trailingSlash: true,
};

module.exports = nextConfig;
</file>

<file path="app/blog/routes/BlogIndexRoute.tsx">
import Link from 'next/link';
import {
  Badge,
  Container,
  EmptyState,
  EntryList,
  Pagination,
  TabList,
  Tab,
} from '@/app/components';
import { Entry } from '@/app/types';

type Props = {
  entries: Entry[];
  pagination?: React.ComponentProps<typeof Pagination>;
  tag?: string;
};

export default function BlogIndexRoute({ entries, pagination, tag }: Props) {
  return (
    <Container>
      <main>
        <div>
          <div>
            <div className="flex flex-col gap-10">
              <TabList>
                <Tab>
                  <Link
                    href="/blog/"
                    className="inline-block rounded-t-lg border-b-2 border-primary p-4"
                    aria-current="page"
                  >
                    Blog
                  </Link>
                </Tab>
                <Tab>
                  <Link
                    href="/blog/zenn/"
                    className="inline-block rounded-t-lg border-b-2 border-transparent p-4 hover:border-gray-300 hover:text-gray-600 dark:hover:text-gray-300"
                  >
                    Zenn
                  </Link>
                </Tab>
              </TabList>
              <div>
                {entries.length > 0 ? (
                  <div className="flex flex-col gap-10">
                    {tag !== undefined && (
                      <div>
                        <div className="mb-4 flex items-center justify-between">
                          <div className="m-1 inline-flex flex-1">
                            <span>
                              <span className="text-sm">タグ:</span>
                            </span>
                            <span className="inline-flex flex-1 flex-wrap items-center gap-2 px-3 py-0.5 text-sm">
                              <span>
                                <Badge>#{tag}</Badge>
                              </span>
                            </span>
                          </div>
                          <div>
                            <span className="text-sm hover:text-primary">
                              <Link href="/blog/">全て表示する</Link>
                            </span>
                          </div>
                        </div>
                      </div>
                    )}
                    <div className="flex flex-col gap-12">
                      <div>
                        <EntryList entries={entries} />
                      </div>
                      {pagination !== undefined &&
                        pagination.pages.length > 0 && (
                          <div className="flex justify-center">
                            <Pagination {...pagination} />
                          </div>
                        )}
                    </div>
                  </div>
                ) : (
                  <EmptyState />
                )}
              </div>
            </div>
          </div>
        </div>
      </main>
    </Container>
  );
}
</file>

<file path="app/blog/search/page/[page]/page.tsx">
import { getBlogEntries } from '../../../api';
import { Metadata } from 'next';
import { getMetadata } from '@/app/api';
import { objToSearchParams } from '@/app/utils';
import acmsPath from '@uidev1116/acms-js-sdk/acmsPath';
import BlogIndexRoute from '@/app/blog/routes/BlogIndexRoute';

type Props = {
  params: Promise<{ page: string }>;
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
};

export async function generateMetadata(props: Props): Promise<Metadata> {
  const searchParams = await props.searchParams;
  const params = await props.params;
  return await getMetadata({
    blog: 'blog',
    page: parseInt(params.page, 10),
    searchParams: objToSearchParams(searchParams),
  });
}

export default async function BlogSearchPage(props0: Props) {
  const searchParams = await props0.searchParams;
  const params = await props0.params;
  const page = parseInt(params.page, 10);
  const { entries, pager } = await getBlogEntries({
    page,
    searchParams: objToSearchParams(searchParams),
  });

  const props: React.ComponentProps<typeof BlogIndexRoute> = {
    entries,
    pagination: {
      currentPage: page,
      previous: pager?.previous && {
        ...pager.previous,
        path: `/blog/search/${acmsPath({ page: pager.previous.page })}`,
      },
      pages:
        pager?.pages.map((page) => ({
          ...page,
          path: `/blog/search/${acmsPath({ page: page.page })}`,
        })) || [],
      next: pager?.next && {
        ...pager.next,
        path: `/blog/search/${acmsPath({ page: pager.next.page })}`,
      },
    },
  };

  return <BlogIndexRoute {...props} />;
}
</file>

<file path="app/blog/tag/[tag]/page/[page]/page.tsx">
import { getBlogEntries } from '@/app/blog/api';
import { range } from '@/app/utils';
import { Metadata } from 'next';
import { getMetadata } from '@/app/api';
import BlogIndexRoute from '@/app/blog/routes/BlogIndexRoute';

type Props = {
  params: Promise<{ tag: string; page: string }>;
};

export async function generateMetadata(props: Props): Promise<Metadata> {
  const params = await props.params;

  const { tag, page } = params;

  return await getMetadata({
    blog: 'blog',
    page: parseInt(page, 10),
    tag: [decodeURIComponent(tag)],
  });
}

export async function generateStaticParams({
  params: { tag },
}: {
  params: { tag: string };
}) {
  const { pager } = await getBlogEntries({ tag: [decodeURIComponent(tag)] });
  return range(pager?.firstPage || 1, pager?.lastPage || 1).map((page) => ({
    page: page.toString(),
  }));
}

export default async function BlogIndexPage(props0: {
  params: Promise<{ tag: string; page: string }>;
}) {
  const params = await props0.params;
  const tag = decodeURIComponent(params.tag);
  const page = parseInt(params.page);
  const { entries, pager } = await getBlogEntries({
    tag: [tag],
    page,
  });

  const props: React.ComponentProps<typeof BlogIndexRoute> = {
    entries,
    pagination: {
      currentPage: page,
      previous: pager?.previous,
      pages: pager?.pages || [],
      next: pager?.next,
    },
    tag,
  };

  return <BlogIndexRoute {...props} />;
}
</file>

<file path="app/components/ComboBox/ComboBox.tsx">
'use client';

import { Fragment, Suspense } from 'react';
import { ReadonlyURLSearchParams } from 'next/navigation';
import {
  useCombobox,
  UseComboboxActions,
  type UseComboboxProps,
} from 'downshift';
import { usePageChange } from '@/app/hooks';

type Props<T> = UseComboboxProps<T> & {
  className?: string;
  renderInput: (
    getInputProps: ReturnType<typeof useCombobox>['getInputProps'],
  ) => React.ReactNode;
  renderMenu: (
    isOpen: ReturnType<typeof useCombobox>['isOpen'],
    items: T[],
    inputValue: ReturnType<typeof useCombobox>['inputValue'],
    getMenuProps: ReturnType<typeof useCombobox>['getMenuProps'],
    menuItems: ReturnType<Props<T>['renderMenuItem']>,
  ) => React.ReactNode;
  renderMenuItem: (
    getItemProps: ReturnType<typeof useCombobox>['getItemProps'],
    item: T,
    index: number,
    highlightedIndex: number,
    selectedItem: T | null,
    inputValue: ReturnType<typeof useCombobox>['inputValue'],
  ) => React.ReactNode;
  onPageChange?: (
    pathname: string,
    searchParams: ReadonlyURLSearchParams,
    actions: UseComboboxActions<T>,
  ) => void;
};

function ComboBox<T>({
  className = 'relative',
  renderInput,
  renderMenu,
  renderMenuItem,
  onPageChange = () => {},
  ...useComboboxProps
}: Props<T>) {
  const { items = [] } = useComboboxProps;
  const {
    isOpen,
    inputValue,
    getMenuProps,
    getInputProps,
    highlightedIndex,
    getItemProps,
    selectedItem,
    closeMenu,
    openMenu,
    selectItem,
    setHighlightedIndex,
    setInputValue,
    toggleMenu,
    reset,
  } = useCombobox<T>(useComboboxProps);

  const actions = {
    closeMenu,
    openMenu,
    selectItem,
    setHighlightedIndex,
    setInputValue,
    toggleMenu,
    reset,
  };

  usePageChange((pathname, searchParams) =>
    onPageChange(pathname, searchParams, actions),
  );

  function renderMenuItems() {
    return items.map((item, index) => (
      <Fragment key={index}>
        {renderMenuItem(
          getItemProps,
          item,
          index,
          highlightedIndex,
          selectedItem,
          inputValue,
        )}
      </Fragment>
    ));
  }

  return (
    <div className={className}>
      {renderInput(getInputProps)}
      {renderMenu(isOpen, items, inputValue, getMenuProps, renderMenuItems())}
    </div>
  );
}

export default function ComboBoxSuspense<T>(props: Props<T>) {
  return (
    <Suspense fallback={null}>
      <ComboBox<T> {...props} />
    </Suspense>
  );
}
</file>

<file path="app/components/Footer/Footer.tsx">
import Link from 'next/link';
import type { FooterNavigation } from '@/app/api';

type Props = {
  navigations: FooterNavigation[];
};

export default async function Footer({ navigations }: Props) {
  return (
    <footer className="m-4 rounded-lg bg-white shadow dark:bg-gray-800">
      <div className="mx-auto w-full max-w-screen-xl p-4 md:flex md:items-center md:justify-between">
        <span className="text-sm text-gray-500 dark:text-gray-400 sm:text-center">
          © 2023{' '}
          <Link href="/" className="hover:underline">
            blog.uidev.jp
          </Link>
          . All Rights Reserved.
        </span>
        {navigations.length > 0 && (
          <ul className="mt-3 flex flex-wrap items-center gap-x-4 text-sm font-medium text-gray-500 dark:text-gray-400 sm:mt-0 md:gap-x-6">
            {navigations.map((navigation) => (
              <li key={navigation.url}>
                <Link
                  href={navigation.url}
                  className="hover:underline"
                  target={navigation.target || undefined}
                  rel={
                    navigation.target === '_blank' ? 'noreferrer' : undefined
                  }
                >
                  {navigation.label}
                </Link>
              </li>
            ))}
          </ul>
        )}
      </div>
    </footer>
  );
}
</file>

<file path="app/components/NextNProgress/NextNProgress.tsx">
'use client';

import { isExternalLink } from '@/app/utils';
import { usePathname, useSearchParams } from 'next/navigation';
import NProgress from 'nprogress';
import { Suspense, useEffect } from 'react';

type Props = {
  /**
   * Color for the TopLoader.
   * @default "#29d"
   */
  color?: string;
  /**
   * The initial position for the TopLoader in percentage, 0.08 is 8%.
   * @default 0.08
   */
  initialPosition?: number;
  /**
   * The increament delay speed in milliseconds.
   * @default 200
   */
  crawlSpeed?: number;
  /**
   * The height for the TopLoader in pixels (px).
   * @default 3
   */
  height?: number;
  /**
   * Auto increamenting behaviour for the TopLoader.
   * @default true
   */
  crawl?: boolean;
  /**
   * To show spinner or not.
   * @default true
   */
  showSpinner?: boolean;
  /**
   * Animation settings using easing (a CSS easing string).
   * @default "ease"
   */
  easing?: string;
  /**
   * Animation speed in ms for the TopLoader.
   * @default 200
   */
  speed?: number;
  /**
   * Defines a shadow for the TopLoader.
   * @default "0 0 10px ${color},0 0 5px ${color}"
   *
   * @ you can disable it by setting it to `false`
   */
  shadow?: string | false;
  /**
   * Defines a template for the TopLoader.
   * @default "<div class="bar" role="bar"><div class="peg"></div></div>
   * <div class="spinner" role="spinner"><div class="spinner-icon"></div></div>"
   */
  template?: string;
  /**
   * Defines zIndex for the TopLoader.
   * @default 1600
   *
   */
  zIndex?: number;
  /**
   * To show the TopLoader at bottom.
   * @default false
   *
   */
  showAtBottom?: boolean;
};

function NextNProgress({
  color: propColor,
  height: propHeight,
  showSpinner,
  crawl,
  crawlSpeed,
  initialPosition,
  easing,
  speed,
  shadow,
  template,
  zIndex = 1600,
  showAtBottom = false,
}: Props) {
  const defaultColor = '#29d';
  const defaultHeight = 3;

  const color = propColor ?? defaultColor;
  const height = propHeight ?? defaultHeight;

  // Any falsy (except undefined) will disable the shadow
  const boxShadow =
    !shadow && shadow !== undefined
      ? ''
      : shadow
      ? `box-shadow:${shadow}`
      : `box-shadow:0 0 10px ${color},0 0 5px ${color}`;

  // Check if to show at bottom
  const positionStyle = showAtBottom ? 'bottom: 0;' : 'top: 0;';
  const spinnerPositionStyle = showAtBottom ? 'bottom: 15px;' : 'top: 15px;';

  const styles = (
    <style>
      {`#nprogress{pointer-events:none}#nprogress .bar{background:${color};position:fixed;z-index:${zIndex};${positionStyle}left:0;width:100%;height:${height}px}#nprogress .peg{display:block;position:absolute;right:0;width:100px;height:100%;${boxShadow};opacity:1;-webkit-transform:rotate(3deg) translate(0px,-4px);-ms-transform:rotate(3deg) translate(0px,-4px);transform:rotate(3deg) translate(0px,-4px)}#nprogress .spinner{display:block;position:fixed;z-index:${zIndex};${spinnerPositionStyle}right:15px}#nprogress .spinner-icon{width:18px;height:18px;box-sizing:border-box;border:2px solid transparent;border-top-color:${color};border-left-color:${color};border-radius:50%;-webkit-animation:nprogress-spinner 400ms linear infinite;animation:nprogress-spinner 400ms linear infinite}.nprogress-custom-parent{overflow:hidden;position:relative}.nprogress-custom-parent #nprogress .bar,.nprogress-custom-parent #nprogress .spinner{position:absolute}@-webkit-keyframes nprogress-spinner{0%{-webkit-transform:rotate(0deg)}100%{-webkit-transform:rotate(360deg)}}@keyframes nprogress-spinner{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}`}
    </style>
  );

  useEffect(() => {
    NProgress.configure({
      showSpinner: showSpinner ?? true,
      trickle: crawl ?? true,
      trickleSpeed: crawlSpeed ?? 200,
      minimum: initialPosition ?? 0.08,
      easing: easing ?? 'ease',
      speed: speed ?? 200,
      template:
        template ??
        '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>',
    });

    function isAnchorOfCurrentUrl(currentUrl: string, newUrl: string) {
      const currentUrlObj = new URL(currentUrl);
      const newUrlObj = new URL(newUrl);
      // Compare hostname, pathname, and search parameters
      if (
        currentUrlObj.hostname === newUrlObj.hostname &&
        currentUrlObj.pathname === newUrlObj.pathname &&
        currentUrlObj.search === newUrlObj.search
      ) {
        // Check if the new URL is just an anchor of the current URL page
        const currentHash = currentUrlObj.hash;
        const newHash = newUrlObj.hash;
        return (
          currentHash !== newHash &&
          currentUrlObj.href.replace(currentHash, '') ===
            newUrlObj.href.replace(newHash, '')
        );
      }
      return false;
    }

    var npgclass = document.querySelectorAll('html');
    function findClosestAnchor(
      element: HTMLElement | null,
    ): HTMLAnchorElement | null {
      while (element && element.tagName.toLowerCase() !== 'a') {
        element = element.parentElement;
      }
      return element as HTMLAnchorElement;
    }
    function handleClick(event: MouseEvent) {
      try {
        const target = event.target as HTMLElement;
        const anchor = findClosestAnchor(target);
        const newUrl = anchor?.href;
        if (!newUrl) {
          return;
        }

        const currentUrl = window.location.href;
        const isExtarnalLink = isExternalLink(newUrl);
        const isTargetBlank = (anchor as HTMLAnchorElement).target === '_blank';
        const isBlob = newUrl.startsWith('blob:');
        const isAnchor = isAnchorOfCurrentUrl(currentUrl, newUrl);

        if (isAnchor || isExtarnalLink || isTargetBlank) {
          return;
        }

        if (newUrl === currentUrl || isBlob || event.ctrlKey) {
          NProgress.start();
          NProgress.done();
          [].forEach.call(npgclass, function (el: Element) {
            el.classList.remove('nprogress-busy');
          });
        }
      } catch (err) {
        // Log the error in development only!
        // console.log('NextTopLoader error: ', err);
        NProgress.start();
        NProgress.done();
      }
    }

    // Add the global click event listener
    document.addEventListener('click', handleClick);

    // Clean up the global click event listener when the component is unmounted
    return () => {
      document.removeEventListener('click', handleClick);
    };
  }, [
    crawl,
    crawlSpeed,
    easing,
    initialPosition,
    shadow,
    showSpinner,
    speed,
    template,
  ]);

  const pathname = usePathname();
  const searchParams = useSearchParams();
  useEffect(() => {
    NProgress.start();
    NProgress.done();
  }, [pathname, searchParams]);

  return styles;
}

export default function NextNProgressSuspense(props: Props) {
  return (
    <Suspense fallback={null}>
      <NextNProgress {...props} />
    </Suspense>
  );
}
</file>

<file path="app/stores/color-theme.tsx">
'use client';

import {
  Dispatch,
  SetStateAction,
  createContext,
  useContext,
  useEffect,
  useMemo,
} from 'react';
import { useLocalStorage } from 'react-use';

export type ColorTheme = 'light' | 'dark' | undefined;
export interface ColorThemeContextType {
  colorTheme: ColorTheme;
  changeColorTheme: Dispatch<SetStateAction<ColorTheme>>;
  removeColorTheme: () => void;
}
const ColorThemeContext = createContext<ColorThemeContextType>({
  colorTheme: undefined,
  changeColorTheme: () => {},
  removeColorTheme: () => {},
});

const STORAGE_KEY = 'color-theme';

function ColorThemeContextProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const [colorTheme, changeColorTheme, removeColorTheme] =
    useLocalStorage<ColorTheme>(STORAGE_KEY);

  const value = useMemo(() => {
    return {
      colorTheme,
      changeColorTheme,
      removeColorTheme,
    };
  }, [colorTheme, changeColorTheme, removeColorTheme]);

  useEffect(() => {
    if (isDarkMode(colorTheme)) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  }, [colorTheme]);

  return (
    <ColorThemeContext.Provider value={value}>
      <script
        dangerouslySetInnerHTML={{
          __html: `
            if ((localStorage['${STORAGE_KEY}'] !== undefined && JSON.parse(localStorage['${STORAGE_KEY}']) === 'dark') || (!('${STORAGE_KEY}' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
              document.documentElement.classList.add('dark')
            } else {
              document.documentElement.classList.remove('dark')
            }
          `,
        }}
      />
      {children}
    </ColorThemeContext.Provider>
  );
}

function useColorThemeStore() {
  return useContext(ColorThemeContext);
}

function isDarkMode(colorTheme: ColorTheme) {
  if (colorTheme === 'dark') {
    return true;
  }

  if (
    colorTheme === undefined &&
    window.matchMedia('(prefers-color-scheme: dark)').matches
  ) {
    return true;
  }

  return false;
}

export default ColorThemeContextProvider;
export { useColorThemeStore, isDarkMode };
</file>

<file path="app/blog/search/page.tsx">
import acmsPath from '@uidev1116/acms-js-sdk/acmsPath';
import { getBlogEntries } from '../api';
import { Metadata } from 'next';
import { getMetadata } from '@/app/api';
import { objToSearchParams } from '@/app/utils';
import BlogIndexRoute from '../routes/BlogIndexRoute';

export const dynamic = 'force-dynamic';

type Props = {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
};

export async function generateMetadata(props: Props): Promise<Metadata> {
  const searchParams = await props.searchParams;
  return await getMetadata({
    blog: 'blog',
    searchParams: objToSearchParams(searchParams),
  });
}

export default async function BlogSearchPage(props0: Props) {
  const searchParams = await props0.searchParams;
  const { entries, pager } = await getBlogEntries({
    searchParams: objToSearchParams(searchParams),
  });

  const props: React.ComponentProps<typeof BlogIndexRoute> = {
    entries,
    pagination: {
      currentPage: 1,
      previous: pager?.previous && {
        ...pager.previous,
        path: `/blog/search/${acmsPath({ page: pager.previous.page })}`,
      },
      pages:
        pager?.pages.map((page) => ({
          ...page,
          path: `/blog/search/${acmsPath({ page: page.page })}`,
        })) || [],
      next: pager?.next && {
        ...pager.next,
        path: `/blog/search/${acmsPath({ page: pager.next.page })}`,
      },
    },
  };

  return <BlogIndexRoute {...props} />;
}
</file>

<file path="app/components/RichLink/RichLink.tsx">
import clsx from 'clsx';
import { forwardRef } from 'react';

type Props = React.ComponentPropsWithoutRef<'a'> & {
  siteName: string;
  title: string;
  description: string;
  imageSrc: string;
};

export default forwardRef<HTMLAnchorElement, Props>(function RichLink(
  { className, imageSrc, siteName, title, description, ...anchorProps },
  ref,
) {
  return (
    <a
      className={clsx(
        'text-card-foreground block overflow-hidden rounded-lg border bg-white shadow hover:bg-gray-100 dark:border-gray-700 dark:bg-gray-800 dark:hover:bg-gray-700',
        className,
      )}
      ref={ref}
      {...anchorProps}
    >
      <div className="flex">
        <div className="flex-shrink-0">
          <div className="h-[120px] w-[120px] md:h-[157px] md:w-auto md:max-w-[256px]">
            {/* eslint-disable-next-line @next/next/no-img-element */}
            <img
              className="h-full w-full object-cover"
              src={imageSrc}
              alt={`${siteName}のサムネイル画像`}
              width="120"
              height="120"
            />
          </div>
        </div>
        <div className="flex flex-col justify-between p-4">
          <div className="space-y-2">
            <h3 className="js-except line-clamp-1 text-base font-medium leading-tight tracking-tight text-black hover:underline dark:text-white md:line-clamp-2">
              {title}
            </h3>
            <p className="line-clamp-2 text-sm text-gray-500">{description}</p>
          </div>
          <div className="flex justify-end">
            <p className="text-sm text-gray-500">{siteName}</p>
          </div>
        </div>
      </div>
    </a>
  );
});
</file>

<file path="app/components/Unit/Types/MediaUnit/MediaUnit.tsx">
import Image from 'next/image';
import nl2br from '@/app/utils/react-nl2br';
import { ConditionalWrapper } from '../../..';
import type { Unit, MediaUnit } from '@/app/types';
import { ASSETS_HOST, MEDIA_BASE_URL } from '@/app/config/acms';

export default function MediaUnit({ media }: Unit<MediaUnit>) {
  const render = () => {
    if (media.type === 'image' || media.type === 'svg') {
      return (
        <>
          <ConditionalWrapper
            condition={media.link !== ''}
            wrapper={(children) => {
              const { pathname } = new URL(media.link);
              return (
                <a
                  href={new URL(pathname, ASSETS_HOST).toString()}
                  className="js-smartphoto"
                  data-group={media.eid}
                  data-caption={media.caption.replace(/\r?\n/g, '')}
                >
                  {children}
                </a>
              );
            }}
          >
            <Image
              src={new URL(media.path, MEDIA_BASE_URL).toString()}
              width={media.x}
              height={media.y || undefined}
              alt={media.alt}
            />
          </ConditionalWrapper>
          {media.caption && <p>{nl2br(media.caption)}</p>}
        </>
      );
    } else if (media.type === 'file') {
      return (
        <>
          <a href={media.link} target="_blank" rel="noreferrer noopener">
            {media.thumbnail && media.useIcon === false ? (
              <Image
                src={new URL(media.path, MEDIA_BASE_URL).toString()}
                alt={media.alt}
              />
            ) : (
              <Image className="columnIcon" src="icon" alt={media.alt} />
            )}
          </a>
          {media.caption && <p>{nl2br(media.caption)}</p>}
        </>
      );
    }
  };
  return <div>{render()}</div>;
}
</file>

<file path="app/components/ZennArticleList/ZennArticleList.tsx">
import { ZennArticle } from '@/app/types';
import { Badge, Card, CardFooter, CardHeader } from '..';
import { formatISO9075 } from 'date-fns';
import dynamic from 'next/dynamic';

const CreatedTime = dynamic(() =>
  import('@/app/components/CreatedTime').then((mod) => mod.CreatedTime),
);

type Props = {
  articles: ZennArticle[];
  className?: string;
};

export default function ZennArticleList({
  articles = [],
  className = 'grid gap-4 md:grid-cols-2',
}: Props) {
  return (
    <ul className={className}>
      {articles.map((article) => (
        <li key={article.id}>
          <article className="h-full">
            <a href={article.url} target="_blank" rel="noreferrer noopener">
              <Card>
                <CardHeader>
                  <div className="flex items-center justify-between">
                    <CreatedTime
                      createdAt={formatISO9075(article.publishedAt)}
                      className="text-sm font-light text-gray-600 dark:text-gray-400"
                    />
                  </div>
                  <h5 className="text-2xl font-bold tracking-tight text-gray-900 dark:text-white">
                    {article.title}
                  </h5>
                </CardHeader>
                <CardFooter>
                  <Badge>{article.articleType}</Badge>
                </CardFooter>
              </Card>
            </a>
          </article>
        </li>
      ))}
    </ul>
  );
}
</file>

<file path="app/hooks/index.ts">
export * from './useBlogEntriesSwrMutation';
export * from './useBrowser';
export * from './usePageChange';
export * from './useUrlMatch';
</file>

<file path="types/env.d.ts">
namespace NodeJS {
  interface ProcessEnv {
    ACMS_API_HOST: string;
    ACMS_API_KEY: string;
    ACMS_API_PREVIEW_KEY: string;
    ACMS_ASSETS_HOST: string;
    DOMAIN: string;
  }
}
</file>

<file path="tailwind.config.js">
const plugin = require('tailwindcss/plugin');
const colors = require('tailwindcss/colors');

/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: 'class',
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
    './node_modules/flowbite/**/*.js',
  ],
  safelist: [
    '[&_th]:whitespace-nowrap',
    '[&_td]:whitespace-nowrap',
    '[&_th]:table-cell',
    '[&_td]:table-cell',
    '!font-bold',
    '!align-top',
    '!align-middle',
    '!align-bottom',
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          DEFAULT: colors.yellow[300],
          lightest: colors.yellow[50],
          lighter: colors.yellow[100],
          darker: colors.yellow[400],
          darkest: colors.yellow[600],
        },
      },
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic':
          'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
      },
      typography: {
        DEFAULT: {
          css: {
            'table th': {
              color: 'var(--tw-format-headings)',
              fontWeight: 600,
              verticalAlign: 'bottom',
              padding: '0.5555556em 0.5714286em 0.5714286em',
              backgroundColor: 'var(--tw-format-th-bg)',
            },
            table: {
              marginTop: 0,
              marginBottom: 0,
            },
          },
        },
      },
    },
  },
  plugins: [
    require('flowbite/plugin'),
    require('flowbite-typography'),
    plugin(function ({ addBase, addComponents, addUtilities, theme }) {
      addBase({
        html: {
          scrollPaddingTop: theme('spacing.20'),
          scrollBehavior: 'smooth',
        },
        body: {
          backgroundColor: theme('colors.white'),
          color: theme('colors.gray.900'),
        },
        '.dark body': {
          backgroundColor: theme('colors.gray.900'),
          color: theme('colors.white'),
        },
      });
      // addComponents({
      //   '.card': {
      //     backgroundColor: theme('colors.white'),
      //     borderRadius: theme('borderRadius.lg'),
      //     padding: theme('spacing.6'),
      //     boxShadow: theme('boxShadow.xl'),
      //   }
      // })
      // addUtilities({
      //   '.content-auto': {
      //     contentVisibility: 'auto',
      //   }
      // })
    }),
  ],
};
</file>

<file path="app/blog/tag/[tag]/page.tsx">
import { getBlogEntries } from '@/app/blog/api';
import { Metadata } from 'next';
import { getMetadata } from '@/app/api';
import BlogIndexRoute from '@/app/blog/routes/BlogIndexRoute';

type Props = {
  params: Promise<{ tag: string }>;
};

export async function generateMetadata(props: Props): Promise<Metadata> {
  const params = await props.params;

  const { tag } = params;

  return await getMetadata({
    blog: 'blog',
    tag: [decodeURIComponent(tag)],
  });
}

export default async function BlogIndexPage(props0: Props) {
  const params = await props0.params;
  const tag = decodeURIComponent(params.tag);
  const { entries, pager } = await getBlogEntries({ tag: [tag] });

  const props: React.ComponentProps<typeof BlogIndexRoute> = {
    entries,
    pagination: {
      currentPage: 1,
      previous: pager?.previous,
      pages: pager?.pages || [],
      next: pager?.next,
    },
    tag,
  };

  return <BlogIndexRoute {...props} />;
}
</file>

<file path="app/components/CreatedTime/CreatedTime.tsx">
'use client';

import {
  differenceInDays,
  differenceInHours,
  differenceInMinutes,
  differenceInMonths,
  differenceInSeconds,
  differenceInWeeks,
  format,
  formatISO9075,
} from 'date-fns';

type Props = Omit<React.ComponentProps<'time'>, 'dateTime'> & {
  createdAt: string;
};

function formatCreatedAt(date: Date, base: Date) {
  const diffInSecs = differenceInSeconds(base, date);
  if (diffInSecs < 60) {
    return `${diffInSecs}秒前`;
  }

  const diffInMins = differenceInMinutes(base, date);
  if (diffInMins < 60) {
    return `${diffInMins}分前`;
  }

  const diffInHours = differenceInHours(base, date);
  if (diffInHours < 24) {
    return `${diffInHours}時間前`;
  }

  const diffInDays = differenceInDays(base, date);
  if (diffInDays < 7) {
    return `${diffInDays}日前`;
  }

  const diffInWeeks = differenceInWeeks(base, date);
  if (diffInWeeks < 4) {
    return `${diffInWeeks}週間前`;
  }

  const diffInMonths = differenceInMonths(base, date);
  // 4週間前でも 0ヶ月前と表示されるため、条件を足して絞り込む
  if (diffInWeeks >= 4 && diffInMonths < 2) {
    return `1ヶ月前`;
  }

  if (diffInMonths < 7) {
    return `${diffInMonths}ヶ月前`;
  }

  // 半年以上前の日付は、絶対日時で表示する
  return format(date, 'yyyy/MM/dd');
}

export default function CreatedTime({ createdAt, className }: Props) {
  const now = new Date();
  return (
    <time dateTime={formatISO9075(new Date(createdAt))} className={className}>
      {formatCreatedAt(new Date(createdAt), now)}
    </time>
  );
}
</file>

<file path="app/components/index.ts">
export * from './Badge';
export * from './BuildInJs';
export * from './Card';
export * from './Collapse';
export * from './ComboBox';
export * from './ConditionalWrapper';
export * from './Container';
export * from './CreatedTime';
export * from './EmptyState';
export * from './EntryList';
export * from './Footer';
export * from './BlogSearchForm';
export * from './Header';
export * from './NextNProgress';
export * from './Pagination';
export * from './RichLink';
export * from './ShareSocialMedia';
export * from './Spinner';
export * from './Tabs';
export * from './TagList';
export * from './ThemeColorSwitcher';
export * from './Unit';
export * from './UnitIndex';
export * from './ZennArticleList';
export * from './Unit/Types';
</file>

<file path="app/config/acms.ts">
export const API_HOST = process.env.ACMS_API_HOST;
export const API_KEY = process.env.ACMS_API_KEY;
export const PREVIEW_KEY = process.env.ACMS_API_PREVIEW_KEY;
export const ASSETS_HOST = process.env.ACMS_ASSETS_HOST;
export const MEDIA_BASE_URL = `${ASSETS_HOST}/media/`;
export const ARCHIVES_BASE_URL = `${ASSETS_HOST}/archives/`;
export const STORAGE_BASE_URL = `${ASSETS_HOST}/storage/`;
</file>

<file path="app/components/BlogSearchForm/BlogSearchForm.tsx">
'use client';

import type { Entry } from '@/app/types';
import {
  UseComboboxActions,
  UseComboboxStateChange,
  useCombobox,
} from 'downshift';
import { ComponentProps, useRef } from 'react';
import { encodeUri } from '@/app/utils';
import { clsx } from 'clsx';
import { ReadonlyURLSearchParams, useRouter } from 'next/navigation';
import dynamic from 'next/dynamic';
import useBlogEntriesSwrMutation from '@/app/hooks/useBlogEntriesSwrMutation/useBlogEntriesSwrMutation';
import { Spinner } from '@/app/components/Spinner';

type Props = {
  id: string;
};

const ComboBox = dynamic(
  () => import('@/app/components/ComboBox').then((mod) => mod.ComboBox<Entry>),
  { ssr: false },
);

export default function BlogSearchForm({ id }: Props) {
  const router = useRouter();
  const { entries, error, trigger, reset, isMutating } =
    useBlogEntriesSwrMutation();

  const formRef = useRef<HTMLFormElement>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  function navigateToSearchPage() {
    if (formRef.current === null) {
      return;
    }
    const formData = new FormData(formRef.current);
    const keyword = formData.get('keyword');

    if (keyword === null || keyword === '') {
      return;
    }
    router.push(`/blog/search/?keyword=${encodeUri(keyword as string)}`);
    inputRef.current?.blur();
  }

  function handleSubmit(event: React.FormEvent<HTMLFormElement>) {
    event.preventDefault();
    navigateToSearchPage();
  }

  async function handleInputValueChange({
    inputValue,
  }: UseComboboxStateChange<Entry>) {
    if (inputValue === undefined || inputValue === '') {
      return reset();
    }
    await trigger({ keyword: inputValue });
  }

  function itemToString(item: Entry | null) {
    return item ? item.title : '';
  }

  function renderInput(
    ...args: Parameters<ComponentProps<typeof ComboBox>['renderInput']>
  ) {
    const [getInputProps] = args;

    return (
      <div>
        <div className="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3">
          <svg
            className="h-4 w-4 text-gray-500 dark:text-gray-400"
            aria-hidden="true"
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 20 20"
          >
            <path
              stroke="currentColor"
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth="2"
              d="m19 19-4-4m0-7A7 7 0 1 1 1 8a7 7 0 0 1 14 0Z"
            />
          </svg>
          <span className="sr-only">検索アイコン</span>
        </div>
        <input
          type="text"
          name="keyword"
          className="block w-full rounded-lg border border-gray-300 bg-gray-50 py-2 pl-10 pr-8 text-base text-gray-900 focus:border-primary focus:ring-primary dark:border-gray-600 dark:bg-gray-700 dark:text-white dark:placeholder-gray-400 dark:focus:border-primary dark:focus:ring-primary"
          placeholder="検索..."
          {...getInputProps({
            ref: inputRef,
            'aria-label': '検索',
          })}
        />
        {isMutating && (
          <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3">
            <Spinner />
          </div>
        )}
      </div>
    );
  }

  function renderMenu(
    ...args: Parameters<ComponentProps<typeof ComboBox>['renderMenu']>
  ) {
    const [isOpen, , , getMenuProps, menuItems] = args;
    return (
      <div>
        <ul
          className={clsx(
            'absolute z-10 mt-1 max-h-80 w-full overflow-scroll border-gray-200 bg-white p-0 text-black shadow-md dark:border-gray-700 dark:bg-gray-900 dark:text-white',
            {
              hidden: !isOpen,
            },
          )}
          {...getMenuProps()}
        >
          {error ? (
            <li className="flex flex-col px-3 py-2 shadow-sm">
              <span className="font-sm">記事の検索に失敗しました。</span>
            </li>
          ) : (
            menuItems
          )}
        </ul>
      </div>
    );
  }

  function renderMenuItem(
    ...args: Parameters<ComponentProps<typeof ComboBox>['renderMenuItem']>
  ) {
    const [getItemProps, item, index, highlightedIndex, selectedItem] = args;
    return (
      <li
        className={clsx(
          highlightedIndex === index && 'bg-gray-100 dark:bg-gray-700',
          selectedItem === item && 'font-bold',
          'flex flex-col px-3 py-2 shadow-sm',
        )}
        {...getItemProps({ item, index })}
      >
        <span>{item.title}</span>
      </li>
    );
  }

  function handleSelectedItemChange({
    selectedItem,
  }: UseComboboxStateChange<Entry>) {
    if (selectedItem === null || selectedItem === undefined) {
      return;
    }

    router.push(selectedItem.path);
    inputRef.current?.blur();
  }

  function handlePageChange(
    _: string,
    searchParams: ReadonlyURLSearchParams,
    { reset, setInputValue }: UseComboboxActions<Entry>,
  ) {
    const keyword = searchParams.get('keyword');
    if (keyword === null) {
      return reset();
    }
    setInputValue(keyword);
  }

  function handleStateChange(change: UseComboboxStateChange<Entry>) {
    if (change.type === useCombobox.stateChangeTypes.InputKeyDownEnter) {
      if (change?.selectedItem == null) {
        navigateToSearchPage();
      }
    }
  }

  return (
    <form ref={formRef} id={id} action="" role="search" onSubmit={handleSubmit}>
      <ComboBox
        id={`${id}-combobox`}
        items={entries}
        onInputValueChange={handleInputValueChange}
        onSelectedItemChange={handleSelectedItemChange}
        itemToString={itemToString}
        renderInput={renderInput}
        renderMenu={renderMenu}
        renderMenuItem={renderMenuItem}
        onPageChange={handlePageChange}
        onStateChange={handleStateChange}
      />
    </form>
  );
}
</file>

<file path="app/api/index.ts">
import { Metadata, MetadataRoute } from 'next';
import { MEDIA_BASE_URL } from '../config/acms';
import type { Entry, RootBlog } from '../types';
import { deleteNewLine, resolveRequestCache, truncate } from '../utils';
import acmsPath, { type AcmsContext } from '@uidev1116/acms-js-sdk/acmsPath';
import { BASE_URL } from '../config';
import acmsClient from '../lib/acms';

type EntriesResponse = {
  indexPath: string;
  indexBlogName: string;
  entries: Entry[];
};

export type GlobalNavigation = {
  label: string;
  level: number;
  url: string;
  target: '_blank' | '';
};

export type FooterNavigation = {
  label: string;
  level: number;
  url: string;
  target: '_blank' | '';
};

type Ogp = {
  title: string;
  description: string;
  keywords: string;
  image?: {
    path: string;
    width: number;
    height: number;
  };
};

export async function getBlogEntries(): Promise<EntriesResponse> {
  const { data } = await acmsClient.get(
    {
      api: 'summary_top_index',
    },
    { requestInit: { cache: resolveRequestCache() } },
  );
  const { indexUrl, indexBlogName, entry: entries = [] } = data;

  return {
    indexPath: new URL(indexUrl).pathname,
    indexBlogName: indexBlogName,
    entries: entries.map((entry: any) => ({
      id: entry.eid,
      code: entry.ecd,
      sort: entry.sort,
      csort: entry.csort,
      usort: entry.usort,
      status: entry.status,
      title: entry.title,
      path: new URL(entry.url).pathname,
      isNew: entry.isNew,
      createdAt: new Date(entry.datetime),
      updatedAt: new Date(entry.updatedAt),
      postedAt: new Date(entry.createdAt),
      startAt: new Date(entry.publishStartAt),
      endAt: new Date(entry.publishEndAt),
      summary: entry.summary || '',
      tags: (entry.tags || []).map(
        ({ name, url }: { name: string; url: string }) => ({
          name,
          path: new URL(url).pathname,
        }),
      ),
    })),
  };
}

export async function getGlobalNavigation(): Promise<GlobalNavigation[]> {
  const { data } = await acmsClient.get(
    {
      api: 'navigation_global',
    },
    { requestInit: { cache: resolveRequestCache() } },
  );

  const { 'navigation:loop': navs = [] } = data;

  return navs
    .filter((nav: any) => Array.isArray(nav) === false)
    .map((nav: any) => ({
      label: nav.label,
      level: parseInt(nav.level, 10),
      url: nav[0]['link#front']['url'],
      target: nav[0]['link#front']['target'],
    }));
}

export async function getFooterNavigation(): Promise<FooterNavigation[]> {
  const { data } = await acmsClient.get(
    {
      api: 'navigation_footer',
    },
    { requestInit: { cache: resolveRequestCache() } },
  );

  const { 'navigation:loop': navs = [] } = data;

  return navs
    .filter((nav: any) => Array.isArray(nav) === false)
    .map((nav: any) => ({
      label: nav.label,
      level: parseInt(nav.level, 10),
      url: nav[0]['link#front']['url'],
      target: nav[0]['link#front']['target'],
    }));
}

export async function getRootBlog(): Promise<RootBlog> {
  const { data } = await acmsClient.get(
    {
      blog: 1,
      api: 'BF_ctx',
    },
    { requestInit: { cache: resolveRequestCache() } },
  );

  const {
    id,
    code = '',
    name,
    facebook_account: facebookAccount,
    twitter_account: twitterAccount,
    github_account: githubAccount,
    youtube_account: youtubeAccount,
    google_site_verification: googleSiteVerification,
    ga_tracking_id: gaId = '',
  } = data;

  return {
    id,
    code,
    name,
    path: '/',
    facebookAccount,
    twitterAccount,
    githubAccount,
    youtubeAccount,
    googleSiteVerification,
    gaId,
  };
}

export async function getOgp(acmsContext: AcmsContext = {}): Promise<Ogp> {
  const { data } = await acmsClient.get(
    { ...acmsContext, api: 'ogp' },
    { requestInit: { cache: resolveRequestCache() } },
  );

  const {
    title = '',
    description = '',
    keywords = '',
    image: imagePath = '',
    'image@x': imageWidth = 0,
    'image@y': imageHeight = 0,
  } = data;

  return {
    title,
    description,
    keywords,
    ...(imagePath !== ''
      ? {
          image: {
            path: imagePath,
            width: imageWidth,
            height: imageHeight,
          },
        }
      : {}),
  };
}

export async function getMetadata(
  acmsContext: AcmsContext = {},
): Promise<Metadata> {
  const [
    { title, description, keywords, image },
    { name, twitterAccount, googleSiteVerification },
  ] = await Promise.all([getOgp(acmsContext), getRootBlog()]);

  const { blog, category, entry, page, tag, searchParams } = acmsContext;

  function isNoIndex() {
    if (page != null) {
      return true;
    }

    if (tag != null) {
      return true;
    }

    if (
      searchParams != null &&
      new URLSearchParams(searchParams).get('keyword') !== null
    ) {
      return true;
    }

    return false;
  }

  return {
    metadataBase: new URL(BASE_URL),
    title,
    description: deleteNewLine(truncate(description, 350)),
    keywords: keywords || undefined,
    openGraph: {
      title,
      description: deleteNewLine(truncate(description, 350)),
      url: acmsPath({ blog, category, entry }) || '/',
      siteName: name,
      ...(image
        ? {
            images: [
              {
                url: `${MEDIA_BASE_URL}${image.path}`,
                width: image.width,
                height: image.height,
              },
            ],
          }
        : {}),
      locale: 'ja_JP',
      type: entry ? 'article' : 'website',
    },
    twitter: {
      card: 'summary_large_image',
      title,
      description: deleteNewLine(truncate(description, 350)),
      creator: `@${twitterAccount}`,
      ...(image
        ? {
            image: `${MEDIA_BASE_URL}${image.path}`,
          }
        : {}),
    },
    ...(googleSiteVerification
      ? {
          verification: {
            google: googleSiteVerification,
          },
        }
      : {}),
    formatDetection: {
      email: false,
      address: false,
      telephone: false,
    },
    robots: {
      ...(isNoIndex() ? { index: false } : {}),
    },
  };
}

export async function getGaId(): Promise<string> {
  const { gaId } = await getRootBlog();
  return gaId;
}

export async function getSitemap(): Promise<MetadataRoute.Sitemap> {
  const { data } = await acmsClient.get(
    {
      api: 'sitemap',
    },
    { requestInit: { cache: resolveRequestCache() } },
  );

  const { 'url:loop': urls = [] } = data;

  return urls.map((url: any) => ({
    url: new URL(new URL(url.loc).pathname, BASE_URL).toString(),
    lastModified: url.lastmod,
  }));
}
</file>

<file path="app/components/ThemeColorSwitcher/ThemeColorSwitcher.tsx">
'use client';

import { useBrowser } from '@/app/hooks';
import { isDarkMode, useColorThemeStore } from '@/app/stores/color-theme';
import clsx from 'clsx';
import { initDropdowns } from 'flowbite';
import React, { useEffect, useId, useMemo } from 'react';

const colorThemes = [
  {
    name: 'light',
    icon: (
      <svg
        aria-hidden="true"
        xmlns="http://www.w3.org/2000/svg"
        width="24"
        height="24"
        fill="none"
        viewBox="0 0 24 24"
      >
        <path
          stroke="currentColor"
          strokeLinecap="round"
          strokeLinejoin="round"
          strokeWidth="2"
          d="M12 5V3m0 18v-2M7.05 7.05 5.636 5.636m12.728 12.728L16.95 16.95M5 12H3m18 0h-2M7.05 16.95l-1.414 1.414M18.364 5.636 16.95 7.05M16 12a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z"
        />
      </svg>
    ),
  },
  {
    name: 'dark',
    icon: (
      <svg
        aria-hidden="true"
        xmlns="http://www.w3.org/2000/svg"
        width="24"
        height="24"
        fill="none"
        viewBox="0 0 24 24"
      >
        <path
          stroke="currentColor"
          strokeLinecap="round"
          strokeLinejoin="round"
          strokeWidth="2"
          d="M12 21a9 9 0 0 1-.5-17.986V3c-.354.966-.5 1.911-.5 3a9 9 0 0 0 9 9c.239 0 .254.018.488 0A9.004 9.004 0 0 1 12 21Z"
        />
      </svg>
    ),
  },
  {
    name: 'system',
    icon: (
      <svg
        aria-hidden="true"
        xmlns="http://www.w3.org/2000/svg"
        width="24"
        height="24"
        fill="none"
        viewBox="0 0 24 24"
      >
        <path
          stroke="currentColor"
          strokeLinecap="round"
          strokeLinejoin="round"
          strokeWidth="2"
          d="M12 15v5m-3 0h6M4 11h16M5 15h14a1 1 0 0 0 1-1V5a1 1 0 0 0-1-1H5a1 1 0 0 0-1 1v9a1 1 0 0 0 1 1Z"
        />
      </svg>
    ),
  },
];

function ThemeColorSwitcher() {
  const id = useId();
  const isBrowser = useBrowser();

  useEffect(() => {
    if (isBrowser) {
      initDropdowns();
    }
  }, [isBrowser]);

  const { colorTheme, changeColorTheme, removeColorTheme } =
    useColorThemeStore();

  const colorThemeName = useMemo(() => colorTheme ?? 'system', [colorTheme]);

  function handleClick(colorTheme: 'light' | 'dark' | 'system') {
    if (colorTheme === 'system') {
      removeColorTheme();
    } else {
      changeColorTheme(colorTheme);
    }
    // @ts-ignore
    const dropdown = FlowbiteInstances.getInstance(
      'Dropdown',
      `dropdown-${id}`,
    );
    dropdown.hide();
  }

  function renderIcon(colorTheme?: 'light' | 'dark') {
    if (isBrowser && isDarkMode(colorTheme)) {
      return colorThemes.find((theme) => theme.name === 'dark')?.icon;
    }

    return colorThemes.find((theme) => theme.name === 'light')?.icon;
  }

  if (!isBrowser) {
    return null;
  }

  return (
    <>
      <button
        id={id}
        data-dropdown-toggle={`dropdown-${id}`}
        className={clsx(
          'inline-flex h-10 w-10 items-center justify-center rounded-lg p-2.5 text-sm hover:bg-gray-100 focus:outline-none focus:ring-4 focus:ring-gray-200 dark:hover:bg-gray-700 dark:focus:ring-gray-700',
          {
            'text-primary': isBrowser && colorTheme !== undefined,
            'text-gray-800 dark:text-white':
              isBrowser && colorTheme === undefined,
          },
        )}
        type="button"
      >
        {renderIcon(colorTheme)}
      </button>
      <div
        id={`dropdown-${id}`}
        className="z-10 hidden w-36 divide-y divide-gray-100 rounded-lg bg-white shadow dark:bg-gray-700"
      >
        <ul
          className="py-2 text-sm text-gray-700 dark:text-gray-200"
          aria-labelledby="themeColorSwitcher"
        >
          {colorThemes.map((theme) => (
            <li
              key={theme.name}
              className={clsx('group', {
                'is-selected': theme.name === colorThemeName,
              })}
            >
              <button
                type="button"
                className="block w-full px-4 py-2 text-gray-800 hover:bg-gray-100 group-[.is-selected]:text-primary dark:text-white dark:hover:bg-gray-600"
                onClick={() =>
                  handleClick(theme.name as 'light' | 'dark' | 'system')
                }
              >
                <span className="flex items-center gap-x-2">
                  <span>{theme.icon}</span>
                  <span className="font-bold capitalize">{theme.name}</span>
                </span>
              </button>
            </li>
          ))}
        </ul>
      </div>
    </>
  );
}

export default ThemeColorSwitcher;
</file>

<file path="app/layout.tsx">
import { Header, Footer, NextNProgress, BuildInJs } from './components';
import { GoogleAnalytics } from '@next/third-parties/google';

import { getFooterNavigation, getGaId, getGlobalNavigation } from './api';
import ColorThemeContextProvider from './stores/color-theme';
import './globals.css';

export default async function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const [gaId, globalNavigations, footerNavigations] = await Promise.all([
    getGaId(),
    getGlobalNavigation(),
    getFooterNavigation(),
  ]);

  return (
    <html lang="ja" data-scroll-behavior="smooth" suppressHydrationWarning>
      <body>
        <ColorThemeContextProvider>
          <BuildInJs />
          <Header navigations={globalNavigations} />
          {children}
          <Footer navigations={footerNavigations} />
          <NextNProgress
            color="#fde047" // primary color by tailwind.config.js
            showSpinner={false}
          />
        </ColorThemeContextProvider>
      </body>
      {process.env.NODE_ENV === 'production' && gaId !== '' && (
        <GoogleAnalytics gaId={gaId} />
      )}
    </html>
  );
}
</file>

<file path="app/blog/api/index.ts">
import { resolveRequestCache } from '@/app/utils';
import type { BlogEntry, Tag } from '@/app/types';
import type { AcmsContext } from '@uidev1116/acms-js-sdk/acmsPath';
import acmsClient from '@/app/lib/acms';
import { PREVIEW_KEY } from '@/app/config/acms';

type EntriesResponse = {
  entries: BlogEntry[];
  pager?: {
    firstPage: number;
    lastPage: number;
    previous?: {
      path: string;
      num: number;
      page: number;
    };
    pages: {
      page: number;
      path: string;
    }[];
    next?: {
      path: string;
      num: number;
      page: number;
    };
  };
};

type TagFilterResponse = {
  selected: Tag &
    {
      omitPath: string;
    }[];
  selectable: Tag[];
};

function normalizePath(path: string) {
  return path.replace(/\/keyword\/[^\/]+/, '');
}

export async function getBlogEntries(
  acmsContext: AcmsContext = {},
): Promise<EntriesResponse> {
  const { data } = await acmsClient.get(
    { ...acmsContext, blog: 'blog', api: 'summary_index' },
    { requestInit: { cache: resolveRequestCache() } },
  );

  const { items: entries = [], pagination } = data;

  return {
    entries: entries.map((entry: any) => ({
      id: entry.eid,
      code: entry.ecd,
      sort: entry.sort,
      csort: entry.csort,
      usort: entry.usort,
      status: entry.status,
      title: entry.title,
      path: new URL(entry.url).pathname,
      isNew: entry.isNew,
      createdAt: new Date(entry.datetime),
      updatedAt: new Date(entry.updatedAt),
      postedAt: new Date(entry.createdAt),
      startAt: new Date(entry.publishStartAt),
      endAt: new Date(entry.publishEndAt),
      summary: entry.summary || '',
      tags: (entry.tags || []).map(
        ({ name, url }: { name: string; url: string }) => ({
          name,
          path: new URL(url).pathname,
        }),
      ),
    })),
    ...(pagination !== undefined
      ? {
          pager: {
            firstPage: pagination.firstPage,
            lastPage: pagination.lastPage,
            ...(pagination.prevPage !== null
              ? {
                  previous: {
                    path: normalizePath(new URL(pagination.prevPage.url).pathname),
                    num: pagination.prevPage.count,
                    page: pagination.prevPage.page,
                  },
                }
              : {}),
            pages: (pagination.pages || []).map(
              ({ page, url }: { page: number; url: string }) => ({
                page,
                path: normalizePath(new URL(url).pathname),
              }),
            ),
            ...(pagination.nextPage !== null
              ? {
                  next: {
                    path: normalizePath(
                      new URL(pagination.nextPage.url).pathname,
                    ),
                    num: pagination.nextPage.count,
                    page: pagination.nextPage.page,
                  },
                }
              : {}),
          },
        }
      : {}),
  };
}

export async function getAllBlogEntries(): Promise<BlogEntry[]> {
  const { data } = await acmsClient.get(
    { blog: 'blog', api: 'summary_blog_all' },
    { requestInit: { cache: resolveRequestCache() } },
  );

  const { items: entries = [] } = data;

  return entries.map((entry: any) => ({
    id: entry.eid,
    code: entry.ecd,
    sort: entry.sort,
    csort: entry.csort,
    usort: entry.usort,
    status: entry.status,
    title: entry.title,
    path: new URL(entry.url).pathname,
    isNew: entry.isNew,
    createdAt: new Date(entry.datetime),
  }));
}

export async function getTagRelationalEntries(
  entryCode: string,
  isPreview: boolean = false,
): Promise<BlogEntry[]> {
  const { data } = await acmsClient.get(
    {
      blog: 'blog',
      entry: entryCode,
      api: 'tag_relational_index',
      ...(isPreview
        ? { searchParams: new URLSearchParams({ previewKey: PREVIEW_KEY }) }
        : {}),
    },
    { requestInit: { cache: resolveRequestCache() } },
  );

  const { 'entry:loop': entries = [] } = data;

  return entries.map((entry: any) => ({
    id: entry.eid,
    code: entry.ecd,
    sort: entry.sort,
    csort: entry.csort,
    usort: entry.usort,
    status: entry.status,
    title: entry.title,
    path: new URL(entry.url).pathname,
    createdAt: new Date(entry['date#']),
    updatedAt: new Date(entry['udate#']),
    postedAt: new Date(entry['pdate#']),
    startAt: new Date(entry['sdate#']),
    endAt: new Date(entry['edate#']),
    summary: entry.summary || '',
  }));
}

export async function getBlogEntry(
  entryCode: string,
  isPreview: boolean = false,
): Promise<BlogEntry | null> {
  const { data } = await acmsClient.get(
    {
      blog: 'blog',
      entry: entryCode,
      api: 'body_detail',
      ...(isPreview
        ? { searchParams: new URLSearchParams({ previewKey: PREVIEW_KEY }) }
        : {}),
    },
    { requestInit: { cache: resolveRequestCache() } },
  );

  const { items: entries = [] } = data;

  if (!entries.length) {
    return null;
  }

  const [entry] = entries;
  if (entry.code !== entryCode) {
    return null;
  }

  return {
    id: entry.eid,
    code: entry.ecd,
    sort: entry.sort,
    csort: entry.csort,
    usort: entry.usort,
    status: entry.status,
    title: entry.title,
    path: new URL(entry.url).pathname,
    isNew: entry.isNew,
    createdAt: new Date(entry.datetime),
    updatedAt: new Date(entry.updatedAt),
    postedAt: new Date(entry.createdAt),
    startAt: new Date(entry.publishStartAt),
    endAt: new Date(entry.publishEndAt),
    summary: entry.summary || '',
    tags: (entry.tags || []).map(
      ({ name, url }: { name: string; url: string }) => ({
        name,
        path: new URL(url).pathname,
      }),
    ),
    blog: {
      id: entry.blog.bid,
      code: entry.blog.code,
      name: entry.blog.name,
      path: new URL(entry.blog.url).pathname,
      ogpImageBasePath: entry.blog['ogp_image_base@path'],
    },
    body: entry.body,
  };
}

export async function getTagFilter(tags: string[]): Promise<TagFilterResponse> {
  const { data } = await acmsClient.get(
    {
      blog: 'blog',
      tag: tags,
      api: 'tag_filter',
    },
    { requestInit: { cache: resolveRequestCache() } },
  );

  const { 'selected:loop': selected = [], 'choice:loop': selectable = [] } =
    data;

  return {
    selected: selected.map(
      ({
        name,
        path,
        omitUrl,
      }: {
        name: string;
        path: string;
        omitUrl: string;
      }) => ({
        name,
        path,
        omitPath: new URL(omitUrl).pathname,
      }),
    ),
    selectable: selectable.map(
      ({ name, path }: { name: string; path: string }) => ({
        name,
        path,
      }),
    ),
  };
}
</file>

<file path="app/components/EntryList/EntryList.tsx">
import { Entry } from '@/app/types';
import Link from 'next/link';
import { Card, CardBody, CardFooter, CardHeader, TagList } from '..';
import { formatISO9075 } from 'date-fns';
import dynamic from 'next/dynamic';

const CreatedTime = dynamic(() =>
  import('@/app/components/CreatedTime').then((mod) => mod.CreatedTime),
);

type Props = {
  entries: Entry[];
  className?: string;
};

export default function EntryList({
  entries = [],
  className = 'grid gap-4 md:grid-cols-2',
}: Props) {
  return (
    <ul className={className}>
      {entries.map((entry) => (
        <li key={entry.id}>
          <article className="h-full">
            <Link href={entry.path}>
              <Card>
                <CardHeader>
                  <div className="flex items-center justify-between">
                    <CreatedTime
                      createdAt={formatISO9075(entry.createdAt)}
                      className="text-sm font-light text-gray-600 dark:text-gray-400"
                    />
                  </div>
                  <h3 className="text-2xl font-bold tracking-tight text-gray-900 dark:text-white">
                    {entry.title}
                  </h3>
                </CardHeader>
                {entry.summary && (
                  <CardBody className="flex-1">
                    <p className="font-normal text-gray-700 dark:text-gray-400">
                      {entry.summary}
                    </p>
                  </CardBody>
                )}
                {entry.tags && entry.tags.length > 0 && (
                  <CardFooter>
                    <TagList tags={entry.tags} />
                  </CardFooter>
                )}
              </Card>
            </Link>
          </article>
        </li>
      ))}
    </ul>
  );
}
</file>

<file path="app/blog/[code]/page.tsx">
import { draftMode } from 'next/headers';
import { notFound } from 'next/navigation';
import {
  getAllBlogEntries,
  getTagRelationalEntries,
  getBlogEntry,
} from '../api';
import { Metadata } from 'next';
import { getMetadata } from '@/app/api';
import acmsPath from '@uidev1116/acms-js-sdk/acmsPath';
import BlogDetailRoute from '../routes/BlogDetailRoute';
import { PREVIEW_KEY } from '@/app/config/acms';

export async function generateMetadata(props: {
  params: Promise<{ code: string }>;
}): Promise<Metadata> {
  const params = await props.params;
  const { isEnabled } = await draftMode();
  const { openGraph, twitter, ...rest } = await getMetadata({
    blog: 'blog',
    entry: params.code,
    ...(isEnabled
      ? { searchParams: new URLSearchParams({ previewKey: PREVIEW_KEY }) }
      : {}),
  });
  // OGP画像は動的生成した画像を利用する
  delete openGraph?.images;
  delete twitter?.images;
  return {
    ...rest,
    openGraph,
    twitter,
    alternates: {
      canonical: acmsPath({ blog: 'blog', entry: params.code }),
    },
  };
}

export async function generateStaticParams() {
  const entries = await getAllBlogEntries();

  return entries.map((entry) => ({
    code: entry.code,
  }));
}

export default async function BlogDetailPage(props: {
  params: Promise<{ code: string }>;
}) {
  const params = await props.params;
  const { code } = params;
  const { isEnabled } = await draftMode();
  const entry = await getBlogEntry(code, isEnabled);

  if (entry === null) {
    notFound();
  }

  const relationalEntries = await getTagRelationalEntries(entry.code);
  return (
    <BlogDetailRoute entry={entry} relationalEntries={relationalEntries} />
  );
}
</file>

<file path="app/components/Header/Header.tsx">
import { Collapse, ThemeColorSwitcher } from '@/app/components';
import NavLink from './NavLink';

import type { GlobalNavigation } from '@/app/api';
import { BlogSearchForm } from '@/app/components';
import Logo from './Logo';

type Props = {
  navigations: GlobalNavigation[];
};

export default async function Header({ navigations }: Props) {
  return (
    <header className="sticky top-0 z-10">
      <nav className="left-0 top-0 border-b border-gray-200 bg-white dark:border-gray-600 dark:bg-gray-900">
        <div className="mx-auto flex max-w-screen-xl flex-wrap items-center justify-between p-4">
          <Logo />
          <div className="flex md:order-2">
            <div className="block md:hidden">
              <ThemeColorSwitcher />
            </div>
            <div>
              <Collapse
                toggle="navbar-search"
                className="mr-1 rounded-lg p-2.5 text-sm text-gray-500 hover:bg-gray-100 focus:outline-none focus:ring-4 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-700 md:hidden"
              >
                <svg
                  className="h-5 w-5"
                  aria-hidden="true"
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 20 20"
                >
                  <path
                    stroke="currentColor"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth="2"
                    d="m19 19-4-4m0-7A7 7 0 1 1 1 8a7 7 0 0 1 14 0Z"
                  />
                </svg>
                <span className="sr-only">Search</span>
              </Collapse>
            </div>
            <div className="hidden md:block">
              <div className="flex items-center gap-x-2">
                <div>
                  <ThemeColorSwitcher />
                </div>
                <div className="w-72">
                  <BlogSearchForm id="blog-search-form" />
                </div>
              </div>
            </div>
            <div>
              <Collapse
                toggle="navbar-search"
                className="inline-flex h-10 w-10 items-center justify-center rounded-lg p-2 text-sm text-gray-500 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-gray-200 dark:text-gray-400 dark:hover:bg-gray-700 dark:focus:ring-gray-600 md:hidden"
              >
                <span className="sr-only">Open main menu</span>
                <svg
                  className="h-5 w-5"
                  aria-hidden="true"
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 17 14"
                >
                  <path
                    stroke="currentColor"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth="2"
                    d="M1 1h15M1 7h15M1 13h15"
                  />
                </svg>
              </Collapse>
            </div>
          </div>
          <div
            className="hidden w-full items-center justify-between md:order-1 md:flex md:w-auto"
            id="navbar-search"
          >
            <div className="mt-3 space-y-4 md:mt-0 md:space-y-0">
              <div className="md:hidden">
                <BlogSearchForm id="mobile-blog-search-form" />
              </div>
              <div>
                {navigations.length > 0 && (
                  <ul className="mt-4 flex flex-col rounded-lg border border-gray-100 bg-gray-50 p-4 font-medium dark:border-gray-700 dark:bg-gray-800 md:mt-0 md:flex-row md:space-x-8 md:border-0 md:bg-white md:p-0 md:dark:bg-gray-900">
                    {navigations.map((navigation) => (
                      <li key={navigation.url}>
                        <NavLink
                          href={navigation.url}
                          target={navigation.target || undefined}
                          rel={
                            navigation.target === '_blank'
                              ? 'noreferrer'
                              : undefined
                          }
                        >
                          {navigation.label}
                        </NavLink>
                      </li>
                    ))}
                  </ul>
                )}
              </div>
            </div>
          </div>
        </div>
      </nav>
    </header>
  );
}
</file>

<file path="package.json">
{
  "name": "my-blog-site-frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "TZ='Etc/UTC' next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint .",
    "prepare": "husky install"
  },
  "dependencies": {
    "@next/third-parties": "^15.5.4",
    "@types/node": "20.4.4",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@uidev1116/acms-js-sdk": "^0.0.2",
    "clsx": "^2.0.0",
    "copy-to-clipboard": "^3.3.3",
    "date-fns": "^2.30.0",
    "document-outliner": "^1.1.3",
    "dom-content-loaded": "^1.0.2",
    "downshift": "^8.2.2",
    "eslint": "9.36.0",
    "eslint-config-next": "^15.5.4",
    "feed": "^4.2.2",
    "flowbite": "^2.2.0",
    "html-react-parser": "^5.2.6",
    "leaflet": "^1.9.4",
    "lozad": "^1.16.0",
    "next": "^15.5.4",
    "nprogress": "^0.2.0",
    "react": "^19",
    "react-dom": "^19",
    "react-markdown": "^9.0.1",
    "react-use": "^17.5.0",
    "rehype-raw": "^7.0.0",
    "scroll-hint": "^1.2.5",
    "sharp": "^0.34.4",
    "smartphoto": "^1.6.5",
    "swr": "^2.3.6"
  },
  "devDependencies": {
    "@eslint/compat": "^1.4.0",
    "@eslint/eslintrc": "^3.3.1",
    "@eslint/js": "^9.36.0",
    "@types/leaflet": "^1.9.8",
    "@types/lozad": "^1.16.4",
    "@types/nprogress": "^0.2.3",
    "autoprefixer": "^10.4.14",
    "eslint-config-prettier": "^9.1.2",
    "eslint-plugin-jsx-a11y": "^6.10.2",
    "flowbite-typography": "^1.0.3",
    "husky": "^8.0.3",
    "lint-staged": "^13.2.3",
    "postcss": "^8.4.27",
    "prettier": "^2.8.8",
    "prettier-plugin-tailwindcss": "^0.4.1",
    "tailwindcss": "^3.3.3",
    "typescript": "^5.2.2"
  },
  "volta": {
    "node": "22.19.0"
  }
}
</file>

</files>
